
#ifndef MAPSET_H
#define MAPSET_H

#ifdef __cplusplus                 // Не переносить на С

#ifndef MAPACCES_H
  #include "mapacces.h"
#endif

#define MAXINFOCOUNT 64

// *********************************************************************
//         Коды семантик для логических связей между объектами :
//
// 32801 - признак объекта, имеющего ссылку на подчиненный объект;
// 32802 - признак объекта, на который имеется ссылка от главного объекта;
// 32803 - признак объекта, входящего в группу равноправных объектов.
// *********************************************************************

typedef struct OBJECTCHAIN
{
  OBJECTCHAIN *Next;              // Указатель на следующую структуру
  OBJECTCHAIN *Back;              // Указатель на предыдущую структуру
  int         ObjectCount;        // Количество объектов в цепочке
  TObjectInfo Info[MAXINFOCOUNT]; // Массив Info
}
  OBJECTCHAIN;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++ КЛАСС ОБЪЕКТОВ, ОБЪЕДИНЕННЫХ В ГРУППУ   ++++++++
// ++++++++    ПО СЕМАНТИЧЕСКОЙ ХАРАКТЕРИСТИКЕ      ++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class _DLLCLASS TObjectSet
{

public:

  enum SEMKODGROUP
       {
       EGUITABLE   = GROUPPARTNER, // признак объекта, входящего в группу
                                   // равноправных объектов
                                   // (отметки глубин объединяются в группы);
       GENERAL     = GROUPLEADER,  // признак объекта, имеющего ссылку на
                                   // подчиненный объект
                                   // (отметки глубин ссылаются на подписи);
       SUBORDINATE = GROUPSLAVE,   // признак объекта, на который имеется
                                   // ссылка от главного объекта;
       };

public:

  TObjectSet();

  // semn - тип семантической характеристики для поиска в info
  //        EGUITABLE, GENERAL, SUBORDINATE
  // если semn = 0 - ищет первую попавшуюся групповую семантику
  TObjectSet(TObjectInfo *info, int semn = 0);

  ~TObjectSet();

  // Построить группу по существующей в info групповой семантике
  // semn - тип семантической характеристики для поиска в info
  //        EGUITABLE, GENERAL, SUBORDINATE
  // если semn = 0 - ищет первую попавшуюся групповую семантику
  int Build(TObjectInfo *info, int semn = 0);

  // Построить Select из групповых объектов
  int BuildSelect(TMapSelect *select);

  // Построить группу из объектов карты, включая в нее все
  // объекты подчиненных узлов
  // по существующей в info групповой семантике
  int BuildInsertKnot(TObjectInfo *info);

  // Построить группу равноправных объектов из Select
  // map - карта
  // listnumber - номер листа
  void BuildEguitableSelect(TMap *map, int listnumber);

  // Построить новую группу равноправных объектов
  void BuildEguitable();

  // Построить новую группу, имеющую главный и подчиненные объекты
  void BuildGeneral();

  // Определить наличие открытых данных
  int IsActive();

  // Построение набора путем добавления info
  // =======================================

  // Инициализировать построение набора по существующей в
  // info групповой семантике без дальнейшего поиска
  // объектов на карте (создается только один объект)
  // Для продолжения построения группы использовать
  // функцию AppendNext
  // type - тип группы
  //        если == 0, тип взять из существующей в info
  //        групповой семантики
  // semn - тип семантической характеристики для поиска в info
  //            EGUITABLE, GENERAL, SUBORDINATE
  // если semn = 0 - ищет первую попавшуюся групповую семантику
  // Возвращает предполагаемый тип семантики для следующего объекта
  int InitBuild(TObjectInfo *info, int type = 0, int semn = 0);

  // Продолжить построение группы (добавить следующий объект)
  // type - предполагаемый тип семантики для текущего объекта
  // Возвращает предполагаемый тип семантики для следующего
  // объекта или 0
  int AppendNext(TObjectInfo *info, int type);

  // Создать полную копию группы объектов
  int Object(TObjectSet *set);

  // Перебор элементов
  // =================

  // Запросить количество объектов в группе
  int GetCount();

  // Запросить объект по номеру (с 1)
  TObjectInfo *GetObject(int number);

  // Запросить габариты объектов группы
  DFRAME *ViewObjectFramePlane(DFRAME *frame);

  // Управление списком
  // ==================

  // Добавить равноправный объект группу
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  // Возвращает порядковый номер объекта или 0
  int AppendEguitable(TObjectInfo *info, int save = 0);

  // Добавить подчиненный объект группу
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  // Если объект info содержит групповую семантику и является главным
  // - добавляет групповую семантику (создает новую группу не разрушая старую)
  // Если объект info содержит групповую семантику и является подчиненным
  // - добавляет в набор, изменяя групповую семантику
  // Возвращает порядковый номер объекта или 0
  int AppendSubordinate(TObjectInfo *info, int save = 0);

  // Добавить подчиненный объект группу
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  // Если объект info содержит групповую семантику и является подчиненным
  // - разрушает существующую группу и создает новую
  // Возвращает порядковый номер объекта или 0
  int AppendSubordinateNew(TObjectInfo *info, int save);

  // Добавить главный объект группу
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  // Если объект info содержит групповую семантику и является главным
  // - добавляет в набор, не изменяя групповую семантику
  // Если объект info содержит групповую семантику и является подчиненным
  // - добавляет групповую семантику (создает новую группу не разрушая старую)
  // Возвращает порядковый номер объекта или 0
  int AppendGeneral(TObjectInfo *info, int save = 0);

  // Добавить главный объект группу
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  // Если объект info содержит групповую семантику и является главным
  // - разрушает существующую группу и создает новую
  // Возвращает порядковый номер объекта или 0
  int AppendGeneralNew(TObjectInfo *info, int save);

  // Найти объект в группе по его номеру на листе
  TObjectInfo *Find(int number);

  // Найти главный объект в группе
  // group - номер группы
  TObjectInfo *FindGeneral(long int group = 0);

  // Найти объект с несовпадающей группой, начиная с конкретного номера
  // group - номер группы
  // number - порядковый номер объекта в группе
  TObjectInfo *FindNoEgualGroup(long int group, int *number);

  // Переназначить главный объект в группе
  // number - номер объекта на листе
  // если number = 0, назначается первый попавшийся объект
  int NominateGeneral(int number = 0);

  // Удалить объект из группы по порядковому номеру (с 1)
  // Удаленный заменяется на последний
  // Если объект главный в группе - удаляется вся группа
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  int Remove(int number, int save = 0);

  // Удалить объект из группы по его номеру на листе (с 1)
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  int RemoveNumber(int number, int save = 0);

  // Удалить объект из группы по уникальному номеру
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  int RemoveKey(KEY key, int save = 0);

  // Удалить все объекты из группы
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  void RemoveAll(int save = 0);

  // Проинициализировать группу
  void Clear();

  // Объединить наборы
  // regime -
  //    = 1 -  добавить отдельный объект
  //           если объект главный - создать иерархию, включив только его
  //           в текущий набор
  //           если объект подчиненный или равноправный - включить его в текущий набор,
  //           удалив из set
  //    = 2 -  весь набор
  //           разрушается набор set и все объекты включаются в текущий набор
  //    = 3 -  создать иерархию
  //           найти главный объект набора set и включить его как подчиненный
  //           в текущий набор, создав иерархию
  // info - по какому объекту набора ориентироваться
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  int Union(TObjectSet *set, int regime, TObjectInfo *info,
            int save = 1);

  // Объединить наборы, разрушив набор set
  int UnionWithDestroy(TObjectSet *set, int save);

  // Объединить наборы, создав иерархию (включив главный объект)
  int UnionHierarchy(TObjectSet *set, int save);

  // Запрос общих сведений
  // =====================

  // Карта
  TMap *GetMap();

  // Лист
  int GetListNumber();

  // Номер группы
  long int GetGroupNumber();

  // Тип группы
  // Возвращает - EGUITABLE - группа равноправных объектов
  //            - GENERAL   - группа объектов,
  //                          один из которых главный
  //            - 0 при ошибке
  int GetGroupType();

  // Запросить групповую семантику для конкретной группы
  // groupnumber -  номер группы
  // Возвращает признак объекта или 0
  int GetGroupSemn(TObjectInfo *info, long int groupnumber = 0);

  // Запросить конкретную групповую семантику для группы
  // semn -  тип групповой семантики
  // Возвращает номер группы или 0
  long int GetGroupSemn(TObjectInfo *info, int semn);

  // Код ошибки
  long int GetError() {return ErrorCode;}

  // Запросить/установить признак редактирования данных
  int IsDirty() { return Isdirty; }
  int IsDirty(int flag) { return Isdirty = flag; }

  // Это групповой объект
  // groupnumber - переменная, куда помещается номер группы
  //              ( если он нужен )
  // Возвращает признак объекта или 0
  int IsObjectGroup(TObjectInfo *info, long int *groupnumber = 0);

  // Удалить объект с карты
  // Если объект является групповым и он главный в группе,
  // семантика оставшихся объектов обновляется
  int DeleteObject(TObjectInfo *info);


  // Операции на карте над объектами
  // ================================

  // Удалить все объекты группы с карты
  int Delete();

  // Удалить групповую семантику из объекта
  // group - номер набора
  // если group == 0, то используется GroupNumber
  int DeleteSemantic(TObjectInfo *info, long int group = 0);

  // Удалить всю групповую семантику из объекта
  // group - номер набора
  int DeleteAllSemantic(TObjectInfo *info);

  // Переместить все объекты группы
  // Сместить все координаты объекта на заданную
  // величину (delta) в метрах на местности
  // update - обновлять объекты на карте или нет
  int Move(DOUBLEPOINT * delta, int update = 0);

  // Переместить все объекты группы
  // Сместить все координаты метрики на заданную
  // величину (delta)
  // Метрика объекта изменяется без учета карты (Site или Map)
  int MoveData(DOUBLEPOINT *delta);

  // Повернуть все объекты вокруг заданного в прямоугольной
  // системе X,Y (в м.)  центра ( center )
  // на заданный угол ( anglevalue ).
  // Угол задается в радианах и может принимать значения:
  // от 0 до PI и от 0 до -PI или
  // от 0 до PI и от 0 до 2PI
  // При ошибке возвращает 0
  int Rotate(DOUBLEPOINT *center,double anglevalue,
             int update = 0);

  // Повернуть все объекты (повернуть все координаты метрики)
  // вокруг заданного в прямоугольной
  // системе X,Y центра ( center )
  // на заданный угол ( anglevalue ).
  // Центр и метрика должны быть в одной системе отсчета.
  // Угол задается в радианах и может принимать значения:
  // от 0 до PI и от 0 до -PI или
  // от 0 до PI и от 0 до 2PI
  // Метрика объекта изменяется без учета карты (Site или Map)
  // При ошибке возвращает 0
  int RotateData(DOUBLEPOINT *center,double anglevalue);

  // Масштабировать(factor) все объекты группы
  // factor - коэффициент
  // deltanull - смещение относительно 0
  // При ошибке возвращает ноль
  int ScopeData(DOUBLEPOINT *factor, DOUBLEPOINT *deltanull);

  // Масштабировать(factor) и сдвинуть(delta)
  // все объекты группы
  // factor - коэффициент
  // deltanull - смещение относительно 0
  // delta - непосредственно смещение
  // При ошибке возвращает ноль
  int ScopeAndRelocateData(DOUBLEPOINT *factor,
                           DOUBLEPOINT *deltanull,
                           DOUBLEPOINT *delta);

  // Восстановить объекты группы на карте
  // после операций удаления, перемещения
  int Revert();

  // Сохранить группу
  // always - сохранять всегда или только, если были изменения
  //        = 0 - были изменения
  //        = 1 - всегда
  int Save(int always = 0);

  // Перенести группу объектов на другую карту  
  // При переносе объекта выполняется замена внутреннего кода  
  // для нового классификатора, если код не найден -  
  // он устанавливается в ноль  
  // Метрика преобразуется в соответствии с типом карты
  // map - карта
  // AutoCorrect - автоматическая коррекция номера группы
  // list - номер листа
  // При ошибке возвращает ноль 
  // В случае удачи возвращает количество скопированных объектов
  int ChangeMap(TMap * map, const int AutoCorrect = 0, const int list = 1);
  
  // Установить номер группы
  // newGroupNumber - новый номер группы:
  //   0 - используется номер главного объекта(группа с главным объктом)
  //     - первый попавшийся номер(группа с равноправными объетами)
  // При ошибке возвращает ноль
  int SetGroupNumber(const int newGroupNumber = 0);

  // Операции отображения
  // ====================

  // Выделить группу
  int PaintGroup(TMapAccess *doc, HDC hDC,
                 RECT& rect, COLORREF color = RGB(0x0,0xFF,0xFF),
                 int thick = 2);

protected:

  // Функции инициализации и вспомогательные
  // =======================================

  // Инициализировать данные класса
  void InitObjectChain();

  // Инициализировать звено цепочки
  // Возвращает адрес последнего или нового звена или 0
  OBJECTCHAIN *InitSectionChain();

  // Очистить переменные класса
  void InitVariable();

  // Освободить память
  void FreeMemory();

  // Добавить объект
  // dirty - обновлять семантику или нет
  // Возвращает порядковый номер объекта или 0
  int Append(TObjectInfo *info, int dirty = 0);

  // Запросить номер звена в цепочке по номеру объекта (с 1)
  // objchain - порядковый номер объекта в цепочке
  // objsection - порядковый номер объекта в звене
  // Возвращает номер звена в цепочке или 0
  int GetSectionNumber(int objchain, int *objsection);

  // Запросить звено цепочки по номеру звена в цепочке (с 1)
  // Возвращает адрес звена или 0
  OBJECTCHAIN *GetSection(int number);

  // Запрос первого элемента в группе
  TObjectInfo *GetFirst();

  // Запрос следующего элемента в группе
  TObjectInfo *GetNext();

  // Удалить объект из группы
  // Удаленный заменяется на последний
  // Если объект главный в группе - удаляется вся группа
  // save - сохранение в файл
  //      =  0 - не сохранять, 1 - сохранять
  int Remove(TObjectInfo *info, int save = 0);

  // Обновить на листе удаленные из группы объекты,
  // если это не новая группа
  int UpdateDeleteObject();

  // Обновить на листе семантику объектов группы
  // при разрушении группы или удалении главного объекта
  // info - главный объект
  int UpdateSemantic(TObjectInfo *info, long int grnumber = 0);
  
protected:

  // Смещение метрики объекта(для восстановления данных)
  DOUBLEPOINT Delta;
  DOUBLEPOINT Center;
  double Angle;

  long int GroupNumber;             // Номер группы
  long int ErrorCode;               // Код ошибки

  int          ObjectChainCount;    // Количество звеньев
  OBJECTCHAIN *ObjectChainBegin;    // Первое звено цепочки
  int          ObjectCountAll;      // Общее число объектов в цепочке

  TMap *Map;                        // Карта
  int  ListNumber;                  // Номер листа
  int  GroupType;                   // Тип группы
  int  FlagGeneralObject;           // Наличие в группе главного
                                    // объекта, если тип группы GENERAL

  TObjectInfo InfoBuild;            // Объект, с которого началось
                                    // построение группы (Build(TObjectInfo *info))
  int FlagDeleteObject;             // Наличие в группе удаленных объектов

  OBJECTCHAIN *ObjectChainCurrent;  // Текущее звено цепочки
  int          ObjectNumberCurrent; // Текущий объект в текущем звене цепочки
  int          FlagFirst;           // Отработала функция запроса
                                    // первого объекта в группе

  // Признак редактирования данных
  int Isdirty;

  int Reserv;

};

#endif  // __cplusplus

#endif  // MAPSET_H
