
#ifndef MAPINFO_H
#define MAPINFO_H

#ifndef MAPDEF_H
 #include "mapdef.h"
#endif

#ifndef MAPHDR_H
  #include "maphdr.h"    // Справочные данные
#endif
#ifndef MAPDAT_H
  #include "mapdat.h"    // Метрика объекта
#endif
#ifndef MAPSEM_H
  #include "mapsem.h"    // Семантика объекта
#endif

#ifndef MAPDRW_H
  #include "mapdrw.h"    // Графическое описание
#endif

#ifndef MAPVEC_H         // Вектор привязки 3D-модели  
  #include "mapvec.h"
#endif

#ifndef MAPERR_RH
  #include "maperr.rh"    // Коды ошибок
#endif

#ifndef MAPGROUP_H
  #include "mapgroup.h"
#endif

#ifndef MAPOLD_H
  #include "mapold.h"
#endif

// DATABUFFERSIZE  - см. MAPDAT.H  // РАЗМЕР БУФЕРА МЕТРИКИ
// DRAWBUFFERSIZE  - см. MAPDRW.H  // РАЗМЕР БУФЕРА ГРАФИКИ
// SEMNBUFFERSIZE  - см. MAPSEM.H  // РАЗМЕР БУФЕРА CЕМАНТИКИ
#define DESCBUFFERSIZE (64L)       // РАЗМЕР БУФЕРА СПРАВОЧНЫХ ДАННЫХ

// СОКРАЩЕННОЕ ОПИСАНИЕ НАЙДЕННОГО ОБ'ЕКТА
typedef struct
{
  int         ListNumber;        // НОМЕР ЛИСТА ВЫБРАННОГО ОБ'ЕКТА
  int         ObjectNumber;      // НОМЕР ВЫБРАННОГО ОБ'ЕКТА В ЛИСТЕ
  TMap *      Map;               // ОПИСАНИЕ ЭЛЕКТРОННОЙ КАРТЫ
}
  MAPOBJDESC;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++     КЛАСС : ОБНОВЛЕНИЕ ОБЩИХ ТОЧЕК              ++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// Признак обновления точек
enum UPDATEPOINTCOMMON
{
  UCP_MAP = 1,        // На карте
  UCP_LAYER = 2       // В слое
};

// СТРУКТУРА POINTREGISTER (для обновления общих точек)
typedef struct
{
  DOUBLEPOINT PointOld;    // Старые координаты
  DOUBLEPOINT PointNew;    // Новые координаты
  double HNew;             // Новая высота
  double Limit;            // Окрестность обновления
  int Flag;
}
  POINTREGISTER;


class _DLLCLASS TObjectInfo;

class _DLLCLASS TPointRegister
{
public:

  TPointRegister();
  ~TPointRegister();

  // Загрузить Info
  int SetInfo(TObjectInfo *info = 0);

  // Загрузить PointRegister
  int Load(TPointRegister *pointregister = 0);

  // Проинициализировать структуру данных
  // Создается идентификатор записи,число точек = 0
  // При ошибке возвращает 0
  int Clear();

  // Занести точку
  // xold, yold - старые координаты
  // xnew, ynew - новые координаты
  // hnew - новая высота
  // limit - окрестность обновления
  // При ошибке возвращает 0
  int PutPoint(int flag,double xold, double yold,
                        double xnew, double ynew,
                        double hnew = 0, double limit = DELTANULL);

  // Поставить указатель на точку
  // При ошибке возвращает 0
  char *GetPoint(int number);

  // Обновить общие точки
  int UpdatePoints();

protected:


  // Выделить память под данные
  //  При ошибке возвращает ноль, иначе - новый размер буфера
  int Allocate(int size = 4096);

  //  Увеличить размер буфера данных
  //  При ошибке возвращает ноль, иначе - новый размер буфера
  int Realloc();

  // Поставить указатель на следующую точку
  // При ошибке возвращает 0
  char *GetNextPoint();

  // Поставить указатель на первую точку
  // При ошибке возвращает 0
  char *GetFirstPoint();

public :

  POINTREGISTER HUGER * Point;  // Указатель текущей точки
  long int BufferLength;        // Размер буфера данных
  unsigned int NumberOfPoint;   // Номер текущей точки (начинается с 1)
  unsigned int Count;           // Число точек
  long int Length;              // Длина реальных данных
  char *Memory;                 // Способ обработки памяти в деструкторе
                                // (если != 0, освободить)

  TObjectInfo *Info;
};

void _fastcall pregInit(TPointRegister * pregister);
void _fastcall pregFree(TPointRegister * pregister);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++     КЛАСС : СПИСОК СОЗДАННЫХ ОБЪЕКТОВ КАРТЫ     ++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// СТРУКТУРА OBJECTSLISTDATA
typedef struct
{
  long int ListNumber;         // Номер листа
  long int ObjectNumber;       // Номер объекта на листе
  long int Key;                // Номер объекта на листе
}
  OBJECTSLISTDATA;


typedef struct OBJECTSLIST
{
 OBJECTSLISTDATA HUGER *Object;  // Указатель текущего объекта
 long int BufferLength;          // Размер буфера данных
 long int Length;                // Длина реальных данных
 char *Memory;                   // Способ обработки памяти в деструкторе
 double ErrorSquareProcent;      // Процент для проверки суммы площадей объектов
}
  OBJECTSLIST;


class _DLLCLASS TNewObjectsList : public OBJECTSLIST
{
public:

  TNewObjectsList();
  ~TNewObjectsList();

  // Очистить список объектов
  void Clear();

  // Запрос общего количества объектов
  int GetObjectCount();

  // Запрос номера объекта по порядку в списке (с 1)
  OBJECTSLISTDATA *GetData(int number);

  // Запрос количества объектов на листе
  int GetObjectCount(long int list);

  // Запрос номера объекта в листе по порядковому номеру в
  // списке на заданный лист ( с 1 )
  long int GetObject(long int list, int number);

  // Добавить объект в список
  // list - номер листа
  // object - номер объекта
  int AddObject(long int list, long int object);

  // Запросить процент
  double GetProcent();

  // Установить процент
  void SetProcent(double procent = DELTANULL);

  protected:

  // Выделить память под данные
  //  При ошибке возвращает ноль, иначе - новый размер буфера
  int Allocate(int size = 4096);

  //  Увеличить размер буфера данных
  //  При ошибке возвращает ноль, иначе - новый размер буфера
  int Realloc();
};

// Очистить список объектов
void _fastcall objlClear(TNewObjectsList * objectslist);

// Запрос общего количества объектов
int _fastcall objlGetObjectCount(TNewObjectsList * objectslist);

// Запрос номера объекта по порядку в списке (с 1)
OBJECTSLISTDATA *_fastcall objlGetData(TNewObjectsList * objectslist, int number);

// Выделить память под данные
//  При ошибке возвращает ноль, иначе - новый размер буфера
int _fastcall objlAllocate(TNewObjectsList * objectslist, int size);

//  Увеличить размер буфера данных
//  При ошибке возвращает ноль, иначе - новый размер буфера
int _fastcall objlRealloc(TNewObjectsList * objectslist);

// Запрос количества объектов на листе
int _fastcall objlGetObjectCountInList(TNewObjectsList * objectslist, long int list);

// Запрос номера объекта в листе по порядковому номеру в
// списке на заданный лист ( с 1 )
long int _fastcall objlGetObjectInList(TNewObjectsList * objectslist,
                                 long int list, int number);

// Добавить объект в список
// list - номер листа
// object - номер объекта
int _fastcall objlAddObject(TNewObjectsList * objectslist,
                            long int list, long int object);

// Запросить процент
double _fastcall objlGetProcent(TNewObjectsList * objectslist);                      //09/09/04

// Установить процент
void _fastcall objlSetProcent(TNewObjectsList * objectslist, double procent);        //09/09/04

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ КЛАСС : ИНФОРМАЦИЯ ОБ ОБ'ЕКТЕ ЭЛЕКТРОННОЙ КАРТЫ ++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ВСЕ СИМВОЛЬНЫЕ СТРОКИ ОПИСАНЫ В КОДАХ ANSI/KOI8 !!!

class _DLLCLASS TObjectInfo
{

public:

 // ************************************************************
 //                                                            *
 //         ИНИЦИАЛИЗАЦИЯ ДАННЫХ ОБ'ЕКТА                       *
 //                                                            *
 // ************************************************************

  TObjectInfo();

  ~TObjectInfo();

  TObjectInfo(TMap * map, int listnumber = 1,
                          int kind = IDFLOAT2,int text = 0);

  TObjectInfo(TMap * map,TObjectDesc desc,
                         TObjectData data = (char*)0,
                         TObjectSemn semn = (char*)0,
                         int listnumber = 0, int objectnumber = 0,
                         TObjectDraw draw = (char *)0);

  TObjectInfo(MAPOBJDESC * mapobject);

  TObjectInfo(TObjectInfo * info);


  // Создать полную копию описания произвольного объекта
  // Объект может не иметь метрических (точечный) и семантических данных
  TObjectInfo * Object(TMap * map,TObjectDesc desc,
                        TObjectData data = 0,
                        TObjectSemn semn = 0,
                        int listnumber = 1, int objectnumber = 0,
                        TObjectDraw draw = 0);

  TObjectInfo * Object(MAPOBJDESC * mapobject);

  TObjectInfo * Object(TMap * map, int listnumber,
                       int objectnumber);

  TObjectInfo * Object(TObjectInfo * info = 0);


  //  Создать полную копию описания группового объекта
  //  Объект может не иметь метрических (точечный) и семантических данных
  TObjectInfo * UnionObject(TMap * map,TObjectDesc desc,
                        TObjectData data = (char*)0,
                        TObjectSemn semn = (char*)0,
                        int listnumber = 1, int objectnumber = 0,
                        TObjectDraw draw = (char *)0);

  TObjectInfo * UnionObject(MAPOBJDESC * mapobject);

  TObjectInfo * UnionObject(TObjectInfo * info = 0);


  // Проинициализировать запись метрики заданного типа
  // По умолчанию FLOAT 2-ух мерная
  // text - признак метрики с текстом (объекты типа "подпись")
  // При ошибке возвращает 0
  int CreateData(int kind = IDFLOAT2,int text = 0);

  // Проинициализировать запись справочных данных
  // При ошибке возвращает 0
  int CreateDesc();

  // Проинициализировать запись графического описания объекта
  // При ошибке возвращает 0
  int CreateDraw();

  // Проинициализировать запись семантики
  // При ошибке возвращает 0
  int CreateSemn();

protected :

  // Выделить память для создания нового объекта
  // Проинициализировать записи справочных данных,
  // метрики и семантики
  // По умолчанию метрика FLOAT 2-ух мерная
  // text - признак метрики с текстом (объекты типа "подпись")
  // При ошибке возвращает 0
  int CreateObject(int kind = IDFLOAT2,int text = 0);

  // Удалить размещенные данные
  // Освобождает память, отведенную под хранение данных
  // Обнуляет "указатели"
  void DeleteData();

  // Создать полную копию описания произвольного объекта
  // Объект может не иметь метрических (точечный) и семантических данных
  // Предыдущее описание автоматически удаляется
  // При возникновении ошибки возвращает 0
  // Код ошибки см. Error()
  int CopyData(TObjectDesc desc, TObjectData data = (char *)0,
                                 TObjectSemn semn = (char *)0,
                                 TObjectDraw draw = (char *)0);

 // ************************************************************
 //                                                            *
 //         СОХРАНИТЬ/ВОССТАНОВИТЬ ДАННЫЕ ОБ'ЕКТА              *
 //                                                            *
 // ************************************************************

public :

 // Сохранить данные об объекте в файле
 // Если номер объекта равен нулю - объект добавляется как новый
 // Номер листа в районе должен быть установлен
 // select - признак выборочного обновления объекта
 // (если метрика или семантика не редактировались -
 // они не будут обновляться)
 // При ошибке возвращает ноль
 int _fastcall Commit(int select = 1);

 // Сохранить данные об объекте в файле с выбором листа
 // или делением объекта по листам (при необходимости)
 // Если номер объекта равен нулю - объект добавляется как новый
 // Номер листа в районе должен быть установлен
 // Если объект новый, его номер в листе формируется автоматически
 // select - признак выборочного обновления объекта
 // (если метрика или семантика не редактировались -
 // они не будут обновляться)
 //           0 - обновлять всегда,
 //           1 - обновлять, если были изменения.
 //  list - номер листа, куда сохранить часть объекта,
 //         если объект делится по листам
 //           0 - сохранить все части объекта (куда попадет)
 //           list - сохранить только ту часть, которая попадает
 //                  в лист list
 // objectslist - класс для проверки площадей созданных объектов
 //  если число полученных объектов больше 1 в objectslist
 //  заполняются BaseKey
 // При ошибке возвращает ноль
 int _fastcall CommitWithPlace(int select = 1, int list = 0,
                               TNewObjectsList *objectslist = 0);

 // Удалить объект из карты
 // При ошибке возвращает ноль
 int Delete();

 // Восстановить данные об объекте из файла
 // Номер листа в районе и номер объекта должны быть установлены
 int Revert();

 // ************************************************************
 //                                                            *
 //         ОБРАБОТКА ГРУППОВОГО ОПИСАНИЯ ОБ'ЕКТА              *
 //                                                            *
 // ************************************************************

public :

 //  Добавить объект в группу
 //  this, info - первый объект, второй объект
 //  Режим работы:
 //  this - нет в группе, info - нет в группе  =  новая группа
 //  this - в группе n, info - нет в группе    =  группа n
 //  this - нет в группе, info - в группе n    =  группа n
 //  this - в группе n, info - в группе m      =  группа n
 //  При нормальном завершении возвращает номер группы
 //  При ошибке возвращает 0

 int AppendObjectInGroup(TObjectInfo *info);

 //  Сохранить  данные о групповом объекта в файле
 //  Номер листа в районе и номер объекта должен быть установлен
 //  При ошибке возвращает ноль

 int CommitGroup(int semn = 0, int draw = 0);

 //  Удалить объект из группы
 //  При ошибке возвращает 0

 int DeleteObjectFromGroup();

 //  Удалить все объекты из группы
 //  При ошибке возвращает 0

 int DeleteAllObjectFromGroup();

 //  Объединение метричных данных групповых объектов
 //  limit - допуск для дотягивания (по умолчанию = 1)
 //  objectgroup - описание произвольной группы
 //  (при objectgroup == 0 - данные для объединения - файл *.gdx)
 //  del - признак удаления объектов с листа при сборке
 //        при наличии objectgroup
 //        0 - не удалять
 //        1 - удалять
 //  При ошибке возвращает 0

 int UnionGroupData(double limit = 0, TObjectGroup *objectgroup = 0,
                    int del = 0);



protected :

 //  Создать новый объект
 //  При нарезке создается групповой объект
 //  Если метрика группового объекта редактировалась,
 //  объект (по возможности) будет иметь те же уникальные номера.
 //  Если номер объекта в листе (ObjectNumber) равен 0,
 //  создается объект с новым уникальным номером
 //  listsave - номер листа, куда сохранить часть объекта,
 //             если объект делится по листам
 //           0 - сохранить все части объекта (куда попадет)
 //           listsave - сохранить только ту часть, которая попадает
 //                      в лист listsave
 //  objectslist - класс для проверки площадей созданных объектов
 //  если число полученных объектов больше 1 в objectslist
 //  заполняются BaseKey
 //  При ошибке возвращает 0

 int _fastcall CommitNewObject(int listsave = 0,
                               TNewObjectsList *objectslist = 0);


 // ************************************************************
 //                                                            *
 //         СПРАВОЧНЫЕ ДАННЫЕ ОБ ОБ'ЕКТЕ                       *
 //                                                            *
 // ************************************************************

public :

 // Проверить доступен ли объект для обработки
 // При ошибке возвращает ноль
 int IsActive()
    {
      return ((Desc != 0) && Map);
    }

 // Запросить входит ли объект в группу объектов,
 // объединенных по семантическим характеристикам
 // Возвращает признак объекта (код семантики) или 0
 int IsObjectSet();

 // Запросить название листа на котором расположен объект
 // При ошибке возвращает адрес пустой строки
 const char * ListName();

 // Запросить/Установить номер листа на котором расположен объект
 // При ошибке возвращает ноль
 int ListNumber() { return NumberOfList; }
 int ListNumber(int list);

 // Запросить условное название
 // характера локализации
 // При ошибке возвращает адрес пустой строки
 const char * LocalName(int local,
                        int language = ML_RUSSIAN);

 // Запросить максимальный размер условного названия
 // характера локализации
 // При ошибке возвращает ноль
 int LocalNameSize();

 // Запросить классификационный код объекта
 // При ошибке возвращает 0 (ноль допустим)
 long int ObjectExcode();

 // Запросить внутренний код объекта
 // При ошибке возвращает 0 (ноль допустим)
 long int ObjectIncode();

 // Запросить габариты объекта в районе в дискретах
 // frame - адрес области для размещения результата
 // force - принудительно пересчитать габариты (!=0) или
 //         запросить текущие (0)
 // При ошибке возвращает 0, иначе - frame
 FRAME * _fastcall ObjectFrame(FRAME * frame, int force = 0);

 // Запросить габариты объекта в метрах
 // frame - адрес области для размещения результата
 // При ошибке возвращает 0, иначе - frame
 DFRAME * _fastcall ObjectFramePlane(DFRAME * frame);

 // Запросить расширенные габариты объекта в метрах
 // для визуализации
 // frame - адрес области для размещения результата
 // force - принудительно пересчитать габариты (!=0) или
 //         запросить текущие (0)
 // При ошибке возвращает 0, иначе - frame
 DFRAME * _fastcall ViewObjectFramePlane(DFRAME * frame, int force = 0);

 // Запросить - растягивается ли объект по метрике
 int IsObjectStretch();

 // Запросить уникальный номер объекта
 // При ошибке возвращает 0 (ноль допустим)
 long int ObjectKey();

 // Запросить характер локализации объекта
 // При ошибке возвращает 0  (ноль допустим)
 int ObjectLocal();

 // Запросить условное название объекта
 // При ошибке возвращает адрес пустой строки
 const char * ObjectName();

 // Запросить максимальный размер условного названия объекта
 // При ошибке возвращает ноль
 int ObjectNameSize();

 // Запросить/Установить номер объекта в листе
 // При ошибке возвращает ноль
 int ObjectNumber() { return NumberOfObject; }
 int ObjectNumber(int number);

 // Запросить название слоя объекта ("Layer" = "Segment")
 // При ошибке возвращает адрес пустой строки
 const char * SegmentName();

 // Запросить максимальный размер названия слоя объекта
 // При ошибке возвращает ноль
 int SegmentNameSize();

 // Запросить номер слоя объекта
 int SegmentNumber();

 // Установить значение границ видимости по классификатору объектов
 void ClearBotTop();

 // Запросить/Установить верхнюю границу видимости объекта
 // scale - масштаб отображения от 1:1 до 1:40 млн.
 int TopScale();
 int TopScale(int scale);

 // Запросить/Установить нижнюю границу видимости объекта
 int BotScale();
 int BotScale(int scale);

 // Запросить/Установить признак построения сплайна по метрике
 int SplineFlag();
 int SplineFlag(int spline);

 // Запрос признака группового объекта
 int IsGroup();

 // Запрос первого объекта в группе
 TObjectInfo *FirstObjectInGroup(TObjectInfo *info);

 // Запрос следующего объекта в группе
 TObjectInfo *NextObjectInGroup(TObjectInfo *info);

 // Проверить попадание объекта в габариты листа
 // возврат -  0 - объект не попадает в лист или ошибка
 int _fastcall InsideObjectList(DFRAME *object, DFRAME *list);

 // Определить наличие пересечения габаритов объектов
 // precision - допуск на расширение габаритов (в метрах)
 // Если габариты объектов не пересекаются, возвращает 0
 // 05/07/00
 int _fastcall IsCrossObjectFrame(TObjectInfo *info, double precision = 0);

 // ************************************************************
 //                                                            *
 //        РЕДАКТИРОВАНИЕ СПРАВОЧНЫХ ДАННЫХ ОБ'ЕКТА            *
 //                                                            *
 // ************************************************************

public :

 // Создать новый объект
 // Выделить память для создания нового объекта
 // Проинициализировать записи справочных данных,
 // метрики и семантики
 // По умолчанию метрика FLOAT 2-ух мерная
 // text - признак метрики с текстом (объекты типа "подпись")
 // При ошибке в параметрах возвращает 0

 int Create(TMap * map,int list = 1,
                       int kind = IDFLOAT2,
                       int text = FALSE)
    {
      return CreateObject(map,list,kind,text);
    }

 int CreateObject(TMap * map,int list = 1,
                             int kind = IDFLOAT2,
                             int text = FALSE);

 // Создать дескриптор подобъекта в записи метрики
 // В конец записи добавляется дескриптор подобъекта
 // Выполняется контроль по длине записи и длине буфера
 // Число точек = 0, номер подобъекта = максимальный номер + 1
 // (как правило, записывается порядковый номер подобъекта)
 // При ошибке возвращает ноль

 int CreateSubject();

 // Вставить дескриптор объекта/подобъекта в записи метрики  10/03/04
 // В указанную позицию записи добавляется дескриптор подобъекта
 // Число точек = 0, номер подобъекта = subject
 // При удачном завершении возвращает 1, иначе 0 (FALSE)

 int InsertSubject(int subject);

 // Удалить подобъект в записи метрики
 // Текущей становится первая точка объекта
 // При ошибке возвращает ноль

 int DeleteSubject(int number);

 // Найти описание объекта в классификаторе и заполнить
 // справочные данные
 // excode - внешний код объекта (например,31120000 - озера)
 // local  - локализация (например,TObjectDesc::LINE - линейный)
 // Используется при создании нового объекта
 // При ошибке возвращает 0

 int _fastcall RegisterObject(long excode,int local);

 // Заполнить описание объекта из классификатора карты
 // incode - внутренний код объекта, номер записи
 // в таблице объектов классификатора
 // При ошибке возвращает 0

 int _fastcall DescribeObject(int incode);

 // Сформировать описание нового графического объекта
 // по номеру слоя (из классификатора карты) и локализации
 // При ошибке возвращает ноль

 int _fastcall RegisterDrawObject(int layer, int local);

 // Изменить описание объекта при изменении семантических
 // характеристик
 // Если вид объекта не изменился возвращает 0
 // При ошибке возвращает 0

 int RedefineObject();

 //  Запросить формат хранения метрики (IDSHORT2,...,IDDOUBLE3)
 //  При ошибке возвращает ноль, иначе - тип формата хранения метрики
 int GetKind();                                       //26/01/05

 // Установить тип и размерность метрики объекта
 // (например : IDFLOAT2,IDDOUBLE3, и т.п.,
 // объекты пользовательской карты всегда имеют тип DOUBLE)
 // Пересчет выполняется с сохранением существующих координат
 // При ошибке возвращает ноль

 int ChangeDataKind(int kind) { return ChangeKind(kind); }

 // Перенести объект на другую карту
 // При переносе объекта выполняется замена внутреннего кода
 // для нового классификатора, если код не найден -
 // он устанавливается в ноль
 // Метрика преобразуется в соответствии с типом карты
 // При ошибке возвращает ноль

 int ChangeMap(TMap * map, int list = 1);

 // Запросить код объекта и удалить служебную семантику
 // с этим кодом (для выгрузки в SXF и т.п.)
 // При ошибке возвращает ноль

 long int GetObjectExcodeAndDelete();

 // ************************************************************
 //                                                            *
 //         ЗАПРОС СЕМАНТИКИ (АТРИБУТОВ) ОБ'ЕКТА               *
 //                                                            *
 // ************************************************************

 // Запросить число семантических характеристик у объекта
 // При ошибке возвращает ноль

 int SemanticAmount();

 // Запросить значение семантической характеристики объекта
 // Значение преобразуется в символьный вид без раскодирования
 // number  - последовательный номер характеристики,
 // place   - адрес размещения строки,
 // maxsize - максимальная длина строки
 // При ошибке возвращает ноль,
 // при успешном выполнении - адрес строки (равен place)

 char * SemanticValue(int number,char * place,int maxsize);

 // Запросить значение семантической характеристики объекта
 // в виде числа с плавающей точкой двойной точности
 // number  - последовательный номер характеристики
 // Если значение семантики не может быть преобразовано
 // к числовому виду или - возвращает ноль

 double SemanticDoubleValue(int number);

 // Запросить значение семантической характеристики объекта
 // в символьном раскодированном виде
 // Например: Для семантики "СОСТОЯНИЕ" значение "5"
 // заменяется на "жилой"
 // number  - последовательный номер характеристики,
 // place   - адрес размещения строки,
 // maxsize - максимальная длина строки
 // При ошибке возвращает ноль,
 // при успешном выполнении - адрес строки (равен place)

 char * _fastcall SemanticValueName(int number,char * place,int maxsize);

 // Запросить значение семантической характеристики объекта
 // в символьном раскодированном виде с добавлением единицы
 // измерения в символьном виде
 // Например: Для семантики "СОСТОЯНИЕ" значение "5"
 // заменяется на "жилой";
 // Для семантики "ВЫСОТА" значение "205,5" заменяется
 // на "205,5 м"
 // number  - последовательный номер характеристики,
 // place   - адрес размещения строки,
 // maxsize - максимальная длина строки
 // При ошибке возвращает ноль,
 // при успешном выполнении - адрес строки (равен place)

 char * SemanticValueFullName(int number,char * place,int maxsize);

 // Запросить значение семантической характеристики объекта
 // Значение преобразуется в символьный вид
 // excode  - внешний код характеристики,
 //           для которой ищется значение,
 // place   - адрес размещения строки,
 // maxsize - максимальная длина строки
 // number  - последовательный номер найденного значения,
 //  не равен последовательному номеру характеристики !
 //  например : код code имеют 3-я и 6-я характеристики,
 //             соответственно для них number = 1 и 2,
 //             а при number = 3  - код возврата будет ноль.
 // При ошибке возвращает ноль,
 // при успешном выполнении - последовательный номер
 // найденной характеристики

 int SemanticCodeValue(int excode,char * place,int maxsize,
                       int number = 1);

 // Запросить название семантической характеристики объекта
 // При ошибке возвращает адрес пустой строки

 const char * SemanticName(int number);

 //  Запросить внешний код семантической характеристики
 //  объекта по последовательному номеру характеристики
 //  При ошибке возвращает 0,
 //  при успешном выполнении - внешний код семантики

 int SemanticCode(int number);

 //  Запросить количество записей в классификаторе
 //  семантики по внешнему коду семантики
 //  excode - внешний код семантики
 //  При ошибке возвращает ноль

 int SemanticClassificatorCount(int excode);

 //  Запросить название значения характеристики из
 //  классификатора семантики по внешнему коду и
 //  последовательному номеру в классификаторе
 //  number - последовательный номер в классификаторе(1,2,3...)
 //  excode - внешний код семантики
 //  При ошибке возвращает адрес пустой строки,
 //  при успешном выполнении - адрес строки

 const char *SemanticClassificatorName(int excode, int number);

 //  Запросить код значения характеристики из
 //  классификатора семантики по внешнему коду и
 //  последовательному номеру в классификаторе
 //  number - последовательный номер в классификаторе(1,2,3...)
 //  excode - внешний код семантики
 //  При ошибке возвращает ноль

 int SemanticClassificatorCode(int excode, int number);

 //  Заполнить структуру описания семантической характеристики
 //  по внешнему коду семантики
 //  semexcode - внешний код семантики
 //  При ошибке возвращает ноль

 int SemanticDescribe(SEMANTICTYPE *semtype, int excode);

 //  Заполнить структуру описания семантической характеристики
 //  по внешнему коду семантики
 //  semexcode - внешний код семантики
 //  При ошибке возвращает ноль

 int SemanticDescribeEx(SEMANTICTYPEEX *semtype, int excode);

 //  Запросить количество доступных семантик на объект
 //  При ошибке возвращает ноль

 int AvailableSemanticCount();

 //  Запросить внешний код доступной семантики на объект
 //  по последовательному номеру доступных семантик
 //  number - последовательный номер доступных семантик (1,2,3...)
 //  При ошибке возвращает ноль

 int AvailableSemanticCode(int number);

 // Запросить общий размер строки для символьной семантики с учетом повтора
 // кода семантики в нескольких характеристиках                      // 27/02/09
 // info    - идентификатор объекта карты в памяти
 // number  - последовательный номер характеристики (c 1)
 // При ошибке возвращает ноль

 int SemanticStringLength(int number);

 // Запросить общий размер строки для символьной семантики с учетом повтора
 // кода семантики в нескольких характеристиках                      // 27/02/09
 // info    - идентификатор объекта карты в памяти
 // number  - последовательный номер характеристики (c 1)
 // При ошибке возвращает ноль

 int SemanticString(int number, char * value, int length);

 protected:

 //  Запросить количество доступных семантик на объект
 //  semscode - массив под существующие семантики
 //  maxcount - максимальное количество характеристик
 //  При ошибке возвращает ноль

 int AvailableSemanticCount(int *semscode, int maxcount);


 // ************************************************************
 //                                                            *
 //       РЕДАКТИРОВАНИЕ СЕМАНТИКИ (АТРИБУТОВ) ОБ'ЕКТА         *
 //                                                            *
 // ************************************************************

public:

 // Добавить новую характеристику в семантику объекта
 // excode  - внешний код характеристики
 // place   - адрес строки,содержащей новое значение
 //           в символьном виде,
 // maxsize - максимальная длина строки
 // (числовые значения будут преобразовываться в двоичный вид)
 // При ошибке возвращает ноль,
 // при успешном выполнении - последовательный номер
 // созданной характеристики

 int AppendSemantic(int excode,char * place,int maxsize);

 // Удалить семантическую характеристику объекта
 // number  - последовательный номер характеристики
 // При ошибке возвращает ноль

 int DeleteSemantic(int number);

 // Изменить значение семантической характеристики объекта
 // number  - последовательный номер характеристики,
 // place   - адрес строки,содержащей новое значение
 //           в символьном виде,
 // maxsize - максимальная длина строки
 // При ошибке возвращает ноль,
 // при успешном выполнении - адрес строки (равен place)

 char * SetSemanticValue(int number,char * place,int maxsize);

 // Изменить значение кода семантической характеристики объекта
 // number  - последовательный номер характеристики
 // excode  - внешний код характеристики
 // При ошибке возвращает ноль,
 // иначе - внутренний код семантики

 int SetSemanticCode(int number,int excode);

 //  Добавить семантику по умолчанию (только пороги),
 //  если она отсутствует
 //  При ошибке возвращает ноль

 int AppendDefaultSemantic();

 //  Добавить обязательную семантику, если она отсутствует
 //  При ошибке возвращает ноль

 int AppendMustSemantic();


 // ************************************************************
 //                                                            *
 //         ЗАПРОС МЕТРИКИ (КООРДИНАТ) ОБ'ЕКТА                 *
 //                                                            *
 // ************************************************************

 // Запрос числа составных частей метрики (подобъектов + 1)
 // При ошибке возвращает ноль

 int PolyCount();

 // Запрос числа точек объекта/подобъекта
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 int PointCount(int subject = 0);

 // Запрос координаты точки объекта/подобъекта
 // в прямоугольной системе в метрах на местности
 // number - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 double XPlane(int number, int subject = 0);
 double XPlane();

 double YPlane(int number, int subject = 0);
 double YPlane();

 double HPlane(int number, int subject = 0);
 double HPlane();

 // ************************************************************
 //                                                            *
 //      ЗАПРОС МЕТРИКИ (ГЕОДЕЗИЧЕСКИХ КООРДИНАТ) ОБ'ЕКТА      *
 //                                                            *
 // ************************************************************

 // Запрос геодезических координат точки объекта/подобъекта
 // number - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 double BGeo(int number = 1,int subject = 0);

 double LGeo(int number = 1,int subject = 0);

 // ************************************************************
 //                                                            *
 //      РЕДАКТИРОВАНИЕ МЕТРИКИ (КООРДИНАТ) ОБ'ЕКТА            *
 //                                                            *
 // ************************************************************

 // РЕЖИМЫ ЗАМЫКАНИЯ ОБ'ЕКТА

 enum { ABR_APPEND = 0,  // Добавить точку в конце объекта
        ABR_LAST   = 1,  // Обновить последнюю точку
        ABR_FIRST  = 2   // Обновить первую точку
      };

 // Замкнуть  объект/подобъект
 // mode - = 0 - добавить последнюю точку
 //              не добавляет, если объект замкнут
 //        = 1 - заменить последнюю точку
 //        = 2 - заменить первую точку
 //        = 3 - добавить последнюю точку
 //        = 4 - добавить первую точку
 // возврат - 1 - замкнут
 // При ошибке возвращает 0

 int Abridge(int number = 0, int mode = 0);

 // Добавить в конец метрики объекта точку
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // Значение координат задано в метрах на местности
 // Для изменения координаты Н необходимо далее
 // выполнить функцию HPlane(...)
 // При ошибке возвращает ноль

 int AppendPointPlane(DOUBLEPOINT * point,int subject = 0);

 int AppendPointPlane(double x,double y,int subject = 0);

 // Изменить формат хранения метрики (IDSHORT2,...,IDDOUBLE3)
 // При ошибке возвращает ноль, иначе - тип нового формата записи !

 int ChangeKind(int type);

 // Удалить заданную точку метрики
 // При ошибке возвращает ноль

 int DeletePointPlane(int number,int subject = 0)
    { return DeletePoint(number,subject); }

 int DeletePoint(int number,int subject = 0);

 // Вставить в метрику объекта точку
 // number - номер точки за которой будет добавлена новая точка
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // Значение координат задано в метрах на местности
 // Для изменения координаты Н необходимо далее
 // выполнить функцию HPlane(...)
 // При ошибке возвращает ноль

 int InsertPointPlane(DOUBLEPOINT * point,int number,int subject = 0)
 {
   if (point)
     return InsertPointPlane(point->X,point->Y,number,subject);
   return 0;
 }

 int InsertPointPlane(double x,double y,int number,int subject = 0);

 //  Вставить точки пересечения в текущий объект и
 //  пересекающийся с ним info
 //  При нормальном завершении возвращает максимальное
 //  число вставленных точек в одном из объектов
 //  При ошибке возвращает 0
 int InsertPointCross(TObjectInfo *info);

 // Изменить координаты точки метрики
 // Значение координат задано в метрах на местности
 // number  - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 int UpdatePointPlane(DOUBLEPOINT * point,int number,int subject = 0)
 {
   if (point)
     return UpdatePointPlane(point->X,point->Y,number,subject);
   return 0;
 }

 int UpdatePointPlane(double x,double y,int number,int subject = 0);

 int UpdatePointPlane(double x,double y,double h,int number,int subject = 0);


 // Редактирование координаты точки объекта в прямоугольной системе
 // в метрах на местности
 // number - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 int XPlane(double x, int number, int subject);

 int YPlane(double y, int number, int subject);

 int HPlane(double h,int number = 1,int subject = 0);

 // Сместить все координаты метрики объекта на заданную
 // величину (delta) в метрах на местности
 // При ошибке возвращает 0

 // Переформировать объект (подобъект), установив первой заданную точку
 // number - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль
 int SetFirstPoint(int number, int subject);                 //20/10/04

 int RelocateObject(DOUBLEPOINT * delta);

 // Повернуть объект вокруг заданного в прямоугольной
 // системе X,Y в м. центра ( center )
 // на заданный угол ( anglevalue ).
 // Угол задается в радианах и может принимать значения:
 // от 0 до PI и от 0 до -PI или
 // от 0 до PI и от 0 до 2PI
 // При ошибке возвращает 0

 int _fastcall RotateObject(DOUBLEPOINT &center,double anglevalue);

 // Масштабировать(factor) метрику объекта
 // factor - коэффициент
 // deltanull - смещение относительно 0
 // При ошибке возвращает ноль

 int _fastcall ScopeObject(DOUBLEPOINT *factor, DOUBLEPOINT *deltanull);

 // Масштабировать (factor) и cместить все координаты метрики
 // объекта на заданную величину (delta)
 // factor - коэффициент
 // deltanull - смещение относительно 0
 // delta - непосредственно смещение
 // При ошибке возвращает ноль

 int _fastcall ScopeAndRelocateObject(DOUBLEPOINT *factor,
                                      DOUBLEPOINT *deltanull,
                                      DOUBLEPOINT *delta);


  // Контроль структуры метрики объекта         // 23/04/04
  // При ошибке возвращает ноль, если метрика исправлялась -
  // возвращает отрицательное значение

  int StructControl();

#ifndef TINYDATA
  // Запросить тип высоты в третьей координате
  // Реально высота может быть и не задана
  // (0 - абсолютная, иначе - относительная)
  int GetHeightType()                             // 17/01/06
  {
    return Data.IsRelativeHeight();
  }

  // Установить тип высоты в третьей координате
  // Значение высоты может быть установлено позднее
  // (0 - абсолютная, иначе - относительная)
  int SetHeightType(int type)                     // 17/01/06
  {
    return Data.SetHeightType(type);
  }
#endif

 // ************************************************************
 //                                                            *
 //  РЕДАКТИРОВАНИЕ МЕТРИКИ (ГЕОДЕЗИЧЕСКИХ КООРДИНАТ) ОБ'ЕКТА  *
 //                                                            *
 // ************************************************************

 // Добавить в конец метрики объекта точку
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // Значение координат задано в радианах
 // При ошибке возвращает ноль

 int AppendPointGeo(double b,double l,int subject = 0);

 // Вставить в метрику объекта точку
 // number - номер точки за которой будет добавлена новая точка
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // Значение координат задано в радианах
 // Для изменения координаты Н необходимо далее
 // выполнить функцию HPlane(...)
 // При ошибке возвращает ноль

 int InsertPointGeo(double b,double l,int number,int subject = 0);

 // Изменить координаты точки метрики
 // Значение координат задано в радианах
 // number  - номер точки
 // subject - номер подобъекта (если = 0, обрабатывается объект)
 // При ошибке возвращает ноль

 int UpdatePointGeo(double b,double l,int number,int subject = 0);

 int UpdatePointGeo(double b,double l,double h,int number,int subject = 0);

 // Установить значение координат в метрах на местности
 // При ошибке возвращает ноль

 int PutDataPlane(TDataEdit *data);

 // Запросить значение координат в метрах на местности
 // Обновляет метрику Data из data
 // При ошибке возвращает ноль

 int GetDataPlane(TDataEdit *data);


 // ************************************************************
 //                                                            *
 //      РЕДАКТИРОВАНИЕ ТЕКСТА ПОДПИСИ                         *
 //                                                            *
 // ************************************************************

public :

  // Текст имеет кодировку UNICODE ?
  int IsUnicodeText() { return Data.IsUnicodeText(); }

  // Запросить содержание текстовой строки
  // text   - адрес для размещения строки
  // length - длина выделенной области под строку
  // При удачном завершении возвращается значение text,
  // переданная строка имеет кодировку ANSI
  // При ошибке возвращает ноль

  char * GetText(char * text,int length,int subject = 0);

  // Установить новое содержание текстовой строки
  // text   - адрес новой строки
  // При удачном завершении возвращается значение text,
  // переданная строка должна иметь кодировку ANSI
  // При ошибке возвращает ноль

  char * PutText(char * text,int subject = 0);

  //  Установить новое содержание текстовой строки
  //  text   - адрес новой строки
  //  При удачном завершении возвращается значение text,
  //  переданная строка должна иметь кодировку UNICODE
  //  При ошибке возвращает ноль

  char * PutTextUnicode(const WCHAR * text, int subject = 0);

  // Запросить длину текста в микронах на карте
  // При масштабируемой подписи возвращает 0
  // При ошибке возвращает 0

  int GetTextLengthMkm(int subject = 0);

  // Запросить способ выравнивания текста по горизонтали
  // у текущего подобъекта
  // (FA_LEFT,FA_RIGHT,FA_CENTER - см. mapgdi.h)

  int GetTextHorizontalAlign(int subject = 0);

  // Запросить способ выравнивания текста по вертикали
  // у текущего подобъекта
  // (FA_BOTTOM,FA_TOP,FA_BASELINE,FA_MIDDLE)

  int GetTextVerticalAlign(int subject = 0);

  // Установить способ выравнивания текста по горизонтали
  // (FA_LEFT,FA_RIGHT,FA_CENTER)
  // subject - номер подобъекта (-1 - установить всем)
  // По умолчанию имеет значение FA_LEFT
  // При успешном выполнении возвращает установленное значение

  int PutTextHorizontalAlign(int align, int subject);

  // Установить способ выравнивания текста по вертикали
  // (FA_BOTTOM,FA_TOP,FA_BASELINE,FA_MIDDLE)
  // subject - номер подобъекта (-1 - установить всем)
  // По умолчанию имеет значение FA_BASELINE
  // При успешном выполнении возвращает установленное значение

  int PutTextVerticalAlign(int align, int subject);


 // ************************************************************
 //                                                            *
 //         РАСЧЕТ ХАРАКТЕРИСТИК ОБ'ЕКТА                       *
 //                                                            *
 // ************************************************************

  //  Определить габариты объекта в дискретах
  //  без учета размера условного знака (только метрика)
  //  frame - адрес структуры для габаритов объекта
  //  При ошибке возвращает 0

  int _fastcall DimensionObject(DFRAME *frame);

  // Определение кратчайшего расстояния от текущего объекта до объекта info
  // subject - номер текущего подобъекта (0-объекта)
  // distance - вычисленное расстояние  в метрах
  // pointinfo - координаты виртуальной точки info в метрах
  // Возвращает номер точки текущего объекта, от которой считается расстояние
  // или 0 в случае ошибки

  int DistanceObject(TObjectInfo * info, int subject,
                     double * distance, DOUBLEPOINT * pointinfo);

  // Определение кратчайшего расстояния от текущего объекта до объекта info
  // по геодезическим координатам
  // subject - номер текущего подобъекта (0-объекта)
  // distance - вычисленное расстояние  в метрах
  // pointinfo - координаты виртуальной точки info в метрах
  // Возвращает номер точки текущего объекта, от которой считается расстояние
  // или 0 в случае ошибки

  int DistanceObjectReal(TObjectInfo * info, int subject,             //15/09/06
                        double * distance, DOUBLEPOINT * pointinfo);

  // Вычисление длины участка объекта (стороны)
  // Для последней точки вычисляет расстояние до первой точки
  // У замкнутых объектов первая и последняя точки совпадают
  // При ошибке возвращает 0 (при совпадении точек также)

  double SideLength(int number,int subject = 0);


  // Вычисление азимута участка объекта (стороны)
  // Возвращает величину угла в радианах
  // Для последней точки вычисляет направление на первую точку
  // У замкнутых объектов первая и последняя точки совпадают
  // При ошибке возвращает 0 (при совпадении точек также)

  double SideAzimuth(int number,int subject = 0);    //16/01/01

  // Вычисление дирекционного угла участка объекта (стороны)
  // Возвращает величину угла в радианах
  // Для последней точки вычисляет направление на первую точку
  // У замкнутых объектов первая и последняя точки совпадают
  // При ошибке возвращает 0 (при совпадении точек также)

  double SideDirection(int number,int subject = 0);

  // Вычисление площади объекта
  // При ошибке возвращает 0

  double Square(int dontreal = 0);               // 22/11/06

  // Вычисление площади объекта/подобъекта по его геодезическим
  // координатам
  // При отсутствии флага возможности расчета геодезических
  // координат возвращает 0
  // subject - номер подобъекта
  //       ( -1 - площадь объекта в вычетом площади подобъектов)
  // Результат в метрах на местности
  // При ошибке возвращает 0

  double SquareReal(int subject = -1);  //03/12/99


  // Вычисление периметра объекта
  // При ошибке возвращает 0

  double Perimeter();

  // Вычисление длины объекта на местности
  // Для подобъектов считается суммарная длина
  // При ошибке возвращает 0

  double Length();

  // Вычисление длины подобъекта
  // subject - номер подобъекта (если = 0, обрабатывается объект)
  // При ошибке возвращает 0
  double SubjectLength(int subject);   //20/01/05

  // Вычисление длины объекта в проекции карты
  // Для подобъектов считается суммарная длина
  // При ошибке возвращает 0

  double ViewLength();

  // Вычисление длины объекта/подобъекта по его геодезическим
  // координатам
  // При отсутствии флага возможности расчета геодезических
  // координат возвращает 0
  // subject - номер подобъекта
  //        (-1 - все подобъекты:  считается суммарная длина)
  // Результат в метрах на местности
  // При ошибке возвращает 0

  double LengthReal(int subject = -1);


  // Найти точку метрики подобъекта, ближайшую к заданной
  // subject - последовательный номер подобъекта
  // (0 - объект, 1 - первый подобъект и т.д.,
  // если равен -1 - поиск по всей метрике)
  // Возвращает номер точки (номер первой точки - 1)
  // При ошибке возвращает 0

  int SeekNearPoint(double x, double y, int subject);


  // Определение координат точки, лежащей на заданном
  // расстоянии (по периметру) от заданной точки
  // number - номер начальной точки
  // distance - расстояние
  // если distance > = 0 - поиск по направлению цифрования
  //               <   0 - поиск против направления цифрования
  // point - координаты выходной точки
  //        (в прямоугольной системе в метрах на местности)
  // subject - номер подобъекта
  // Возвращает номер точки, за которой находится или
  // c которой совпадает
  // Если точки совпадают - возвращает отрицательный номер точки
  // При ошибке возвращает 0

  int SeekVirtualPointByDistance(int number, double distance,
                                 DOUBLEPOINT *point,
                                 int subject = 0);

  // Найти точку на контуре объекта/подобъекта, ближайшую к заданной
  // point - координаты выходной точки
  //        (в прямоугольной системе в метрах на местности)
  // subject - номер объекта (0) или подобъекта (>0)
  // Возвращает номер точки метрики за которой расположена
  // точка на контуре или ноль при ошибке
  // Координаты точки помещаются по адресу point
  // Номер первой точки 1

  int SeekNearVirtualPoint(double x, double y, DOUBLEPOINT * point,
                           int subject = 0);

protected :

  // Установить параметры для вычисления по геодезическим
  // координатам
  // При отсутствии флага возможности расчета геодезических
  // координат или ошибке возвращает 0

  int SetTranslate(TTranslate *translate); // 03/12/99


 // ************************************************************
 //                                                            *
 //     РЕДАКТИРОВАНИЕ ОБЩИХ ТОЧЕК ОБ'ЕКТА                     *
 //                                                            *
 // ************************************************************

public :

 // Обновить общие точки объектов на карте
 // (координаты в прямоугольной системе в метрах на местности)
 // x, y - новые координаты
 // number - номер точки
 // subject - номер подобъекта
 // limit - окрестность обновления
 // При ошибке возвращает 0

 int UpdatePointPlaneInMap(double x,double y, int number,
                           int subject = 0,double limit = DELTANULL);


 // Обновить общие точки объектов на карте
 // (координаты в прямоугольной системе в метрах на местности)
 // x, y, h - новые координаты
 // number - номер точки
 // subject - номер подобъекта
 // limit - окрестность обновления
 // При ошибке возвращает 0

 int UpdatePointPlane3DInMap(double x,double y,double h,
                             int number,
                             int subject = 0,double limit = DELTANULL);

 // Обновить общие точки объектов на карте
 // (координаты в прямоугольной системе в метрах на местности)
 // x, y - новые координаты
 // number - номер точки
 // subject - номер подобъекта
 // limit - окрестность обновления
 // При ошибке возвращает 0

 int UpdatePointPlaneInLayer(double x,double y, int number,
                             int subject = 0,double limit = DELTANULL);

 // Обновить общие точки объектов на карте
 // (координаты в прямоугольной системе в метрах на местности)
 // x, y, h - новые координаты
 // number - номер точки
 // subject - номер подобъекта
 // limit - окрестность обновления
 // При ошибке возвращает 0

 int UpdatePointPlane3DInLayer(double x,double y,double h,
                               int number,
                               int subject = 0,double limit = DELTANULL);

 // ************************************************************
 //                                                            *
 //     РЕДАКТИРОВАНИЕ ГРАФИЧЕСКОГО ОПИСАНИЯ ОБ'ЕКТА           *
 //                                                            *
 //  (Графическое описание имеется, как правило, у объектов    *
 //   пользовательской карты, не связанных с классификатором)  *
 //                                                            *
 // ************************************************************

public :

  // Запросить - имеет ли объект графическое описание
  int IsDrawObject();

  // Запросить количество элементов графического описания
  // При ошибке возвращает 0
  int DrawCount();

  // Запросить вид элемента графического описания
  // по его номеру ( от 1 до DrawCount())
  // Возвращает номер функции типа IMG_XXXXXXX (см. MAPGDI.H)
  // При ошибке возвращает 0
  int DrawImage(int number);

  // Запросить адрес параметров элемента графического описания
  // по его номеру ( от 1 до DrawCount())
  // Возвращает адрес структуры типа IMGXXXXXX, в соответствии
  // с видом элемента (см. MAPGDI.H)
  // При ошибке возвращает 0
  char * DrawParameters(int number);

  // Запросить длину параметров элемента графического описания
  // по его номеру ( от 1 до DrawCount())
  // При ошибке возвращает 0
  int DrawLength(int number);

  // Добавить элемент графического описания объектов
  // При ошибке возвращает ноль,иначе - число элементов в записи
  int AppendDraw(int image,char * parm);

  // Удалить все элементы графического описания объекта
  void ClearDraw();

  // Удалить элемент графического описания объекта
  // number - номер элемента (начиная с 1)
  // При ошибке возвращает ноль
  int DeleteDraw(int number);

 /***************************************************************
 *                                                              *
 *        Обработка резервных файлов ...\LOG\... ^DA,^SE,^HD    *
 *    (содержат копии всех обновляемых объектов листа)          *
 *                                                              *
 ***************************************************************/

  // Последовательный перебор отредактированных копий объекта info
  // copynumber - последовательный номер копии данного объекта (1, 2, ...)
  // в порядке от последней операции редактирования к предыдущей
  // Вызывается с последовательным увеличением copynumber,
  // пока не будет найдена нужная копия или копии закончатся
  // При ошибке возвращает ноль
  int ReadObjectCopyByNumber(int copynumber);

  // Удалить отредактированные копии данного объекта
  // Вызывается после сохранения (Commit) соответсвующей копии объекта
  // на карте (отмене выполненных операций редактирования)
  // Удаляет копии объекта от первой до copynumber
  // Копия copynumber+1 становится первой
  // При ошибке возвращает ноль
  int DeleteObjectCopyToNumber(int copynumber);

  // ************************************************************
  //                                                            *
  //         КОНТРОЛЬ МЕТРИКИ ОБ'ЕКТА                           *
  //                                                            *
  // ************************************************************

  // Контроль структуры метрики линейных и прощадных объектов
  // При ошибке возвращает ноль
  int CheckMetricStructure();

  // Печать сообщения об ошибке
  int ErrorMessage(char * messagetext,
                   int    messagetype, int flagsubject = 0);

  // Запросить код ошибки последней операции
  long int Error() { return ObjectError; }

  // ************************************************************
  //                                                            *
  //         ОБРАБОТКА ВЕКТОРА ПРИВЯЗКИ 3D-МОДЕЛИ               *
  //                                                            *
  // ************************************************************

  // Запросить описание вектора привязки 3D-модели
  // Результат помещается по указателю target
  // Если вектор не задан - все поля структуры обнуляются
  // При ошибке возвращает ноль
  int GetVector(VECDATA * target);

  // Установить описание вектора привязки 3D-модели
  // При ошибке возвращает ноль
  int SetVector(VECDATA * source);

  // Удалить вектор
  void DeleteVector() { SetVector(0); }
  
  
  // Удалить вектор
  void DeleteVector1() { int i = 2; }


  // ************************************************************
  //                                                            *
  //         СПЕЦИАЛЬНЫЕ ОПЕРАЦИИ                               *
  //                                                            *
  // ************************************************************

public :

  operator HOBJ()
  {
    return (HOBJ) this;
  }

protected :

  // Установить код ошибки последней операции
  long int Error(long int error) { return ObjectError = error; }

public:

 double ListX;                  // Координаты юго-западного угла листа
 double ListY;                  // в районе работ в дискретах

 TObjectDesc Desc;              // Справочные данные об объекте карты
 TDataEdit   Data;              // Метрика объекта
 TSemnEdit   Semn;              // Семантика объекта
 TDrawEdit   Draw;              // Графический вид объекта (может отсутствовать)

 long int ObjectError;          // Код ошибки последней операции

 TObjectHead Head;              // Буфер для справочных данных

 VECDATA     Vector;            // Вектор привязки        // 27/06/05
 int         IsVectorDirty;     // Признак обновления вектора
 int         IsVectorSet;       // Признак заполненности вектора

 int NumberOfList;              // Номер листа выбранного об'екта
 int NumberOfObject;            // Номер выбранного об'екта в листе

 TMap * Map;                    // Описание карты, которой принадлежит об'ект


#ifdef __cplusplus // 11/09/01
#ifndef HIDEGDX    // 30/07/01
 TObjectGroup   ObjectGroup;    // Класс обработки групповых об'ектов
#endif
 TPointRegister PointRegister;  // Класс обновления общих точек
#endif
};

typedef TObjectInfo TMapObject;

// Создать полную копию описания произвольного объекта
TObjectInfo *_fastcall infoObject(TObjectInfo *info,
                                  TMap * map, TObjectDesc desc,
                                  OBJECTDATA *data,
                                  SEMANTIC *semn,
                                  int listnumber, int objectnumber,
                                  IMGDRAW *draw);

// Создать копию описания произвольного объекта
TObjectInfo *_fastcall infoObjectDesc(TObjectInfo *info,
                                      MAPOBJDESC * mapobject);

// Создать копию описания произвольного объекта
TObjectInfo *_fastcall infoObjectMap(TObjectInfo *info,
                                     TMap * map, int listnumber,
                                     int objectnumber);

// Создать полную копию описания произвольного объекта
// info - исходный объект,
// dest - копия объекта
TObjectInfo *_fastcall infoObjectInfo(TObjectInfo *dest,
                                      TObjectInfo *info);

//  Добавить новую характеристику в семантику объекта
//  excode  - внешний код характеристики
//  place   - адрес строки,содержащей новое значение
//            в символьном виде,
//  maxsize - максимальная длина строки
//  При ошибке возвращает ноль,
//  при успешном выполнении - последовательный номер
//  созданной характеристики
ptrdiff_t _fastcall infoAppendSemantic(TObjectInfo *info,
                                 int excode, const char *place,
                                 int maxsize);

int _fastcall infoAppendSemanticDouble(TObjectInfo *info,
                                       int excode, double * value);

//  Удалить семантическую характеристику объекта
//  number  - последовательный номер характеристики
//  При ошибке возвращает ноль
int _fastcall infoDeleteSemantic(TObjectInfo *info, int number);

//  Запросить значение семантической характеристики объекта
//  Значение преобразуется в символьный вид
//  code    - внещний код характеристики,для которой ищется значение,
//  place   - адрес размещения строки,
//  maxsize - максимальная длина строки
//  number  - последовательный номер найденного значения,
//   не равен последовательному номеру характеристики !
//   например : код code имеют 3-я и 6-я характеристики,
//              соответственно для них number = 1 и 2,
//              а при number = 3  - код возврата будет ноль.
//  При ошибке возвращает ноль,
//  при успешном выполнении - номер характеристики
int _fastcall infoSemanticCodeValue(TObjectInfo *info,
                                    int excode,char * place,
                                    int maxsize,int number);

//  Изменить значение кода семантической характеристики объекта
//  number  - последовательный номер характеристики
//  excode  - внешний код характеристики
//  При ошибке возвращает ноль
intptr_t _fastcall infoSetSemanticCode(TObjectInfo *info,
                                  int number,int excode);

//  Изменить значение семантической характеристики объекта
//  number  - последовательный номер характеристики,
//  place   - адрес строки,содержащей новое значение
//            в символьном виде,
//  maxsize - максимальная длина строки
//  При ошибке возвращает ноль,
//  при успешном выполнении - адрес строки (равен place)
char *_fastcall infoSetSemanticValue(TObjectInfo *info,
                                     int number,char *place,
                                     int maxsize);

//  Запросить значение семантической характеристики объекта
//  в символьном раскодированном виде
//  Например: Для семантики "СОСТОЯНИЕ" значение "5"
//  заменяется на "жилой"
//  number  - последовательный номер характеристики,
//  place   - адрес размещения строки,
//  maxsize - максимальная длина строки
//  При ошибке возвращает ноль,
//  при успешном выполнении - адрес строки (равен place)
char *_fastcall infoSemanticValueName(TObjectInfo *info,
                                      int number,char * place,
                                      int maxsize);

char *_fastcall infoSemanticValueToString(TRSCDATA * rsc, int code, SEMBLOCK * block,
                                          char * place, int maxsize);

//  Запросить значение семантической характеристики объекта
//  в символьном раскодированном виде с добавлением единицы
//  измерения в символьном виде
//  Например: Для семантики "СОСТОЯНИЕ" значение "5"
//  заменяется на "жилой";
//  Для семантики "ВЫСОТА" значение "205,5" заменяется
//  на "205,5 м"
//  number  - последовательный номер характеристики,
//  place   - адрес размещения строки,
//  maxsize - максимальная длина строки
//  При ошибке возвращает ноль,
//  при успешном выполнении - адрес строки (равен place)
char *_fastcall infoSemanticValueFullName(TObjectInfo *info,
                                          int number,char * place,
                                          int maxsize);

//  Запросить внешний код семантической характеристики
//  объекта по последовательному номеру характеристики
//  При ошибке возвращает 0,
//  при успешном выполнении - внешний код семантики
int _fastcall infoSemanticCode(TObjectInfo *info, int number);

//  Запросить значение семантической характеристики объекта
//  code    - внещний код характеристики,для которой ищется значение,
//  number  - последовательный номер найденного значения,
//  При ошибке возвращает ноль
double _fastcall infoSemanticCodeDoubleValue(TObjectInfo * info,    // 15/04/06
                                             int code, int number);


int _fastcall infoSemanticCodeValueName(TObjectInfo *info,
                                        int excode,char * place,
                                        int maxsize,int number);

//  Запросить количество записей в классификаторе
//  семантики по внешнему коду семантики
//  excode - внешний код семантики
//  При ошибке возвращает ноль
int _fastcall infoSemanticClassificatorCount(TObjectInfo *info,
                                             int excode);

//  Запросить название значения характеристики из
//  классификатора семантики по внешнему коду и
//  последовательному номеру в классификаторе
//  number - последовательный номер в классификаторе(1,2,3...)
//  excode - внешний код семантики
//  При ошибке возвращает ноль,
//  при успешном выполнении - адрес строки
const char *_fastcall infoSemanticClassificatorName(TObjectInfo *info,
                                                    int excode,
                                                    int number);

//  Запросить код значения характеристики из
//  классификатора семантики по внешнему коду и
//  последовательному номеру в классификаторе
//  number - последовательный номер в классификаторе(1,2,3...)
//  excode - внешний код семантики
//  При ошибке возвращает ноль
int _fastcall infoSemanticClassificatorCode(TObjectInfo *info,
                                            int excode, int number);

//  Заполнить структуру описания семантической характеристики
//  по внешнему коду семантики
//  semtype - адрес структуры, в которую будет помещено
//  описание характеристики,
//  excode - внешний код семантики.
//  При ошибке возвращает ноль
int _fastcall infoSemanticDescribe(TObjectInfo *info,
                                   SEMANTICTYPE *semtype,
                                   int excode);

//  Заполнить структуру описания семантической характеристики
//  по внешнему коду семантики
//  semtype - адрес структуры, в которую будет помещено
//  описание характеристики,
//  excode - внешний код семантики.
//  При ошибке возвращает ноль
int _fastcall infoSemanticDescribeEx(TObjectInfo *info,
                                     SEMANTICTYPEEX *semtype,
                                     int excode);

//  Запросить количество доступных семантик на объект
//  При ошибке возвращает ноль
int _fastcall infoAvailableSemanticCount(TObjectInfo *info);

//  Запросить внешний код доступной семантики на объект
//  по последовательному номеру доступных семантик
//  number - последовательный номер доступных семантик (1,2,3...)
//  При ошибке возвращает ноль
int _fastcall infoAvailableSemanticCode(TObjectInfo *info,int number);

//  Добавить семантику по умолчанию (только пороги),
//  если она отсутствует
//  При ошибке возвращает ноль
int _fastcall infoAppendDefaultSemantic(TObjectInfo *info);

//  Добавить обязательную семантику, если она отсутствует
//  При ошибке возвращает ноль
int _fastcall infoAppendMustSemantic(TObjectInfo *info);

 //  Запросить формат хранения метрики (IDSHORT2,...,IDDOUBLE3)
 //  При ошибке возвращает ноль, иначе - тип формата хранения метрики
 int _fastcall infoGetKind(TObjectInfo *info);            //26/01/05

//  Изменить формат хранения метрики (IDSHORT2,...,IDDOUBLE3)
//  При ошибке возвращает ноль, иначе - тип нового формата записи !
int _fastcall infoChangeKind(TObjectInfo *info, int kind);

// Удалить объект из карты
// При ошибке возвращает ноль
int _fastcall infoDelete(TObjectInfo *info);

// Отменить удаление объекта на карте
// При ошибке возвращает ноль
int _fastcall infoUndelete(TObjectInfo *info);

// Установить номер объекта в листе
// При ошибке возвращает ноль
int _fastcall infoObjectNumber(TObjectInfo *info,int number);

//  Установить номер листа на котором расположен объект
//  При ошибке возвращает ноль
int _fastcall infoListNumber(TObjectInfo *info, int list);

//  Сохранить данные об объекте в файле
//  Номер листа в районе должен быть установлен
//  Если объект новый, его номер в листе формируется автоматически
//  При ошибке возвращает ноль
int _fastcall infoCommit(TObjectInfo *info, int select);

// Сохранить данные об объекте в файле
// Если объект новый - выполняется функция mapCommitObject(),
// если такой объект уже был, то сохраняется копия
// объекта с новым уникальным номером
// При ошибке возвращает ноль
int _fastcall infoCommitObjectAsNew(TObjectInfo *info);

//  Сохранить данные об объекте в файле с выбором листа
//  или делением объекта по листам (при необходимости)
//  Номер листа в районе должен быть установлен
//  Если объект новый, его номер в листе формируется автоматически
//  select - признак выборочного обновления объекта
//  (если метрика или семантика не редактировались -
//  они не будут обновляться)
//           0 - обновлять всегда,
//           1 - обновлять, если были изменения.
//  list - номер листа, куда сохранить часть объекта,
//         если объект делится по листам
//           0 - сохранить все части объекта (куда попадет)
//           list - сохранить только ту часть, которая попадает
//                  в лист list
//  objectslist - класс для проверки площадей созданных объектов
//  если число полученных объектов больше 1 в objectslist
//  заполняются BaseKey
//  При ошибке возвращает ноль
int _fastcall infoCommitWithPlace(TObjectInfo *info, int select, int list,
                                  TNewObjectsList *objectslist);

//  Восстановить данные об объекте из файла
//  Номер листа в районе и номер объекта должны быть установлены
//  При ошибке возвращает ноль
int _fastcall infoRevert(TObjectInfo *info);

// Сформировать описание нового графического объекта
// по номеру слоя (из классификатора карты) и локализации
// При ошибке возвращает ноль
int _fastcall infoRegisterDrawObject(TObjectInfo *info, int layer, int local);

//  Найти описание объекта в классификаторе и заполнить
//  справочные данные
//  excode - внешний код объекта (например,31120000 - озера)
//  local  - локализация (например,TObjectDesc::LINE - линейный)
//  Используется при создании нового объекта
//  При ошибке возвращает 0
int _fastcall infoRegisterObject(TObjectInfo *info,long excode,int local);

// Сформировать описание нового объекта      21/11/02
// по короткому имени объекта (ключу)
// name - символьный код объекта в классификаторе (до 31 символа)
// При ошибке возвращает ноль
int _fastcall infoRegisterObjectByKey(TObjectInfo *info,
                                      const char * name);

//  Заполнить описание объекта из классификатора карты
//  incode - внутренний код объекта, номер записи
//  в таблице объектов классификатора
//  При ошибке возвращает 0
int _fastcall infoDescribeObject(TObjectInfo *info, int incode);

// Изменить описание объекта при изменении семантических
// характеристик
// Если вид объекта не изменился возвращает 0
int _fastcall infoRedefineObject(TObjectInfo *info);

//  Запросить содержание текстовой строки
//  text   - адрес для размещения строки
//  length - длина выделенной области под строку
//  При удачном завершении возвращается значение text,
//  переданная строка имеет кодировку ANSI
//  При ошибке возвращает ноль
char *_fastcall infoGetText(TObjectInfo *info,char *text,int length,int subject);

//  Запросить длину текста в микронах на карте
//  При масштабируемой подписи возвращает 0
//  При ошибке возвращает 0
int _fastcall infoGetTextLengthMkm(TObjectInfo *info, int subject);

// Запросить способ выравнивания текста по горизонтали
// (FA_LEFT,FA_RIGHT,FA_CENTER)
int _fastcall infoGetTextHorizontalAlign(TObjectInfo *info, int subject);

// Запросить способ выравнивания текста по вертикали
// (FA_BOTTOM,FA_TOP,FA_BASELINE,FA_MIDDLE)
int _fastcall infoGetTextVerticalAlign(TObjectInfo *info, int subject);

// Установить способ выравнивания текста по горизонтали
// (FA_LEFT,FA_RIGHT,FA_CENTER)
int _fastcall infoPutTextHorizontalAlign(TObjectInfo *info, int align,int subject);

// Установить способ выравнивания текста по вертикали
// (FA_BOTTOM,FA_TOP,FA_BASELINE,FA_MIDDLE)
int _fastcall infoPutTextVerticalAlign(TObjectInfo *info, int align,int subject);

//  Создать новый объект
//  Выделить память для создания нового объекта
//  Проинициализировать записи справочных данных,
//  метрики и семантики
//  По умолчанию метрика FLOAT 2-ух мерная
//  text - признак метрики с текстом (объекты типа "подпись")
//  При ошибке в параметрах возвращает 0
int _fastcall infoCreateMapObject(TObjectInfo *info,
                                  TMap *map,int list,
                                  int kind,int text);

//  Запросить габариты объекта в метрах (по метрике)
//  frame - адрес области для размещения результата
//  При ошибке возвращает 0, иначе - frame
DFRAME *_fastcall infoObjectFramePlane(TObjectInfo *info,
                                       DFRAME * dframe);

// Запросить расширенные габариты объекта в метрах
// для визуализации                                // 09/03/99
// frame - адрес области для размещения результата
// При ошибке возвращает 0, иначе - frame
DFRAME *_fastcall infoViewObjectFramePlane(TObjectInfo *info,
                                           DFRAME * frame,
                                           int force);

//  Запросить габариты объекта в районе в дискретах
//  frame - адрес области для размещения результата
//  При ошибке возвращает 0
FRAME *_fastcall infoObjectFrame(TObjectInfo *info,
                                 FRAME * frame, int force);

//  Вычисление длины участка объекта (стороны)
//  При ошибке возвращает 0 (при совпадении точек также)
double _fastcall infoSideLength(TObjectInfo *info,
                                int number,int subject);

//  Вычисление азимута участка объекта (стороны)
//  Возвращает величину угла в радианах
//  При ошибке возвращает 0 (при совпадении точек также)
double _fastcall infoSideAzimuth(TObjectInfo *info,int number,int subject);

//  Вычисление дирекционного угла участка объекта (стороны)
//  Возвращает величину угла в радианах
//  При ошибке возвращает 0 (при совпадении точек также)
double _fastcall infoSideDirection(TObjectInfo *info,
                                   int number,int subject);

//  Определение кратчайшего расстояния от текущего объекта до объекта info
//  subject - номер текущего подобъекта (0-объекта)
//  distance - вычисленное расстояние  в метрах
//  pointinfo - координаты виртуальной точки info в метрах
//  Возвращает номер точки текущего объекта, от которой считается расстояние
//  или 0 в случае ошибки
int _fastcall infoDistanceObject(TObjectInfo *dest,
                                 TObjectInfo *info, int subject,
                                 double * distance, DOUBLEPOINT * pointinfo);

//  Определение кратчайшего расстояния от текущего объекта до объекта info
//  по геодезическим координатам
//  subject - номер текущего подобъекта (0-объекта)
//  distance - вычисленное расстояние  в метрах
//  pointinfo - координаты виртуальной точки info в метрах
//  Возвращает номер точки текущего объекта, от которой считается расстояние
//  или 0 в случае ошибки
int _fastcall infoDistanceObjectReal(TObjectInfo *dest,             //15/09/06
                                     TObjectInfo *info, int subject,
                                     double * distance, DOUBLEPOINT * pointinfo);

//  Создать новый объект
//  При нарезке создается групповой объект
//  Если метрика группового объекта редактировалась,
//  объект (по возможности) будет иметь те же уникальные номера.
//  Если номер объекта в листе (ObjectNumber) равен 0,
//  создается объект с новым уникальным номером
//  listsave - номер листа, куда сохранить часть объекта,
//             если объект делится по листам
//           0 - сохранить все части объекта (куда попадет)
//           listsave - сохранить только ту часть, которая попадает
//                      в лист listsave
//  objectslist - класс для проверки площадей созданных объектов
//  если число полученных объектов больше 1 в objectslist
//  заполняются BaseKey
//  При нормальном завершении возвращает число объектов
//  При ошибке возвращает 0
int _fastcall infoCommitNewObject(TObjectInfo *info, int listsave,
                                  TNewObjectsList *objectslist);

//  Проверить попадание объекта в габариты листа
//  возврат -  0 - объект не попадает в лист или ошибка
int _fastcall infoInsideObjectList(DFRAME *object, DFRAME *list);

//  Определить габариты объекта в дискретах
//  без учета размера условного знака (только метрика)
//  frame - адрес структуры для габаритов объекта
//  При ошибке возвращает 0
int _fastcall infoDimensionObject(TObjectInfo *info, DFRAME *frame);

// Установить значение границ видимости по классификатору
// объектов     29/11/99
void _fastcall infoClearBotTop(TObjectInfo *info);

// Запросить верхнюю границу видимости объекта
// scale - масштаб отображения от 1:1 до 1:40 млн.
int _fastcall infoTopScale(TObjectInfo *info);

// Установить верхнюю границу видимости объекта
// scale - масштаб отображения от 1:1 до 1:40 млн.
int _fastcall infoSetTopScale(TObjectInfo *info, int scale);

// Запросить нижнюю границу видимости объекта
int _fastcall infoBotScale(TObjectInfo *info);

// Установить нижнюю границу видимости объекта
int _fastcall infoSetBotScale(TObjectInfo *info, int scale);

// Контроль структуры метрики линейных и прощадных объектов
int _fastcall infoCheckMetricStructure(TObjectInfo *info);

//  Печать сообщения об ошибке
int _fastcall infoErrorMessage(TObjectInfo *info,
                               char * messagetext,
                               int    messagetype,
                               int    flagsubject);

// Перенести объект на другую карту
// При переносе объекта выполняется замена внутреннего кода
// для нового классификатора, если код не найден -
// он устанавливается в ноль
// Метрика преобразуется в соответствии с типом карты
// При ошибке возвращает ноль
int _fastcall infoChangeMap(TObjectInfo *info, TMap * map, int list);

//  Запросить код объекта и удалить служебную семантику
//  с этим кодом (для выгрузки в SXF и т.п.)
//  При ошибке возвращает ноль
long int _fastcall infoGetObjectExcodeAndDelete(TObjectInfo *info);

//  Запросить классификационный код объекта
//  При ошибке возвращает 0
long int _fastcall infoObjectExcode(TObjectInfo *info);

// Определение координат точки, лежащей на заданном
// расстоянии (по периметру) от заданной точки
// number - номер начальной точки
// distance - расстояние
// если distance > = 0 - поиск по направлению цифрования
//               <   0 - поиск против направления цифрования
// point - координаты выходной точки
//        (в прямоугольной системе в метрах на местности)
// subject - номер подобъекта
// Возвращает номер точки, за которой находится или
// c которой совпадает
// Если точки совпадают - возвращает отрицательный номер точки
// При ошибке возвращает 0
int _fastcall infoSeekVirtualPointByDistance(TObjectInfo *info,
                                             int number,
                                             double *distance,
                                             DOUBLEPOINT *point,
                                             int subject);

// Найти точку метрики подобъекта, ближайшую к заданной        // 13/02/00
// subject - последовательный номер подобъекта
// (0 - объект, 1 - первый подобъект и т.д.,
// если равен -1 - поиск по всей метрике)
// Возвращает номер точки (номер первой точки - 1)
// При ошибке возвращает 0
int _fastcall infoSeekNearPoint(TObjectInfo *info,
                                double *x, double *y, int subject);

// Найти точку на контуре объекта/подобъекта, ближайшую к заданной
// point - координаты выходной точки
//        (в прямоугольной системе в метрах на местности)
// subject - номер объекта (0) или подобъекта (>0)
// Возвращает номер точки метрики за которой расположена
// точка на контуре или ноль при ошибке
// Координаты точки помещаются по адресу point
// Номер первой точки 1
int _fastcall infoSeekNearVirtualPoint(TObjectInfo *info,
                                       double *x, double *y,
                                       DOUBLEPOINT * point,
                                       int subject);

// Установить параметры для вычисления по геодезическим
// координатам
// При отсутствии флага возможности расчета геодезических
// координат или ошибке возвращает 0
int _fastcall infoSetTranslate(TObjectInfo * map,
                               TRANSLATE *translate);

int _fastcall infoSetTranslateByMap(TMap * map, double* l,           //09/09/04
                                    TRANSLATE *translate);
                                    
// Вычисление длины объекта/подобъекта по его геодезическим
// координатам
// При отсутствии флага возможности расчета геодезических
// координат возвращает 0
// subject - номер подобъекта
//        (-1 - все подобъекты:  считается суммарная длина)
// Результат в метрах на местности
// При ошибке возвращает 0
double _fastcall infoLengthReal(TObjectInfo *info, int subject);

// Вычисление длины объекта от начала до заданной точки
// При ошибке возвращает 0
double _fastcall infoLengthToPoint(TObjectInfo *info, DOUBLEPOINT * point);

// Вычисление длины подобъекта
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает 0
double _fastcall infoSubjectLength(TObjectInfo *info, int subject);  //20/01/05

// Вычисление длины отрезка подобъекта/объекта
// subject - номер подобъекта (если = 0, обрабатывается объект)
// point1, point2 - границы отрезка (производится поиск ближайших точек объекта)
// При ошибке возвращает 0
double infoSubjectCutLength(TObjectInfo *info, long int subject,
                            const DOUBLEPOINT& point1,
                            const DOUBLEPOINT& point2);
			    
// Вычисление площади объекта/подобъекта по его геодезическим
// координатам
// При отсутствии флага возможности расчета геодезических
// координат возвращает 0
// subject - номер подобъекта
//       ( -1 - площадь объекта в вычетом площади подобъектов)
// Результат в метрах на местности
// При ошибке возвращает 0
double _fastcall infoSquareReal(TObjectInfo *info, int subject);

// Определить наличие пересечения габаритов объектов
// precision - допуск на расширение габаритов (в метрах)
// Если габариты объектов не пересекаются, возвращает 0
// 05/07/00
int _fastcall infoIsCrossObjectFrame(TObjectInfo *dest,
                                     TObjectInfo *info,
                                     double *precision);

// Последовательный перебор отредактированных копий объекта info
// copynumber - последовательный номер копии данного объекта (1, 2, ...)
// в порядке от последней операции редактирования к предыдущей
// Вызывается с последовательным увеличением copynumber,
// пока не будет найдена нужная копия или копии закончатся
// При ошибке возвращает ноль
int _fastcall infoReadObjectCopyByNumber(TObjectInfo *info,
                                         int copynumber);

// Запросить название листа на котором расположен объект
// При ошибке возвращает адрес пустой строки
const char *_fastcall infoListName(TObjectInfo *info);

// Создать дескриптор подобъекта в записи метрики
// В конец записи добавляется дескриптор подобъекта
// Выполняется контроль по длине записи и длине буфера
// Число точек = 0, номер подобъекта = максимальный номер + 1
// (как правило, записывается порядковый номер подобъекта)
// При ошибке возвращает ноль
int _fastcall infoCreateSubject(TObjectInfo *info);

// Удалить подобъект в записи метрики
// Текущей становится первая точка объекта
// При ошибке возвращает ноль
int _fastcall infoDeleteSubject(TObjectInfo *info, int number);

// Запрос числа составных частей метрики (подобъектов + 1)
// При ошибке возвращает ноль
int _fastcall infoPolyCount(TObjectInfo *info);

// Запрос числа точек объекта/подобъекта
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoPointCount(TObjectInfo *info,int subject);

// Запрос координаты точки объекта/подобъекта
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoXPlaneNumber(TObjectInfo *info, int number, int subject);

// Запрос координаты текущей точки
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoXPlane(TObjectInfo *info);

// Запрос координаты точки объекта/подобъекта
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoYPlaneNumber(TObjectInfo *info,int number, int subject);

// Запрос координаты текущей точки
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoYPlane(TObjectInfo *info);

// Запрос координаты точки объекта/подобъекта
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoHPlaneNumber(TObjectInfo *info,int number, int subject);

// Запрос координаты текущей точки
// в прямоугольной системе в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoHPlane(TObjectInfo *info);

// Запрос геодезических координат точки объекта/подобъекта
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoBGeo(TObjectInfo *info, int number,int subject);

// Запрос геодезических координат точки объекта/подобъекта
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
double _fastcall infoLGeo(TObjectInfo *info,int number,int subject);

// Замкнуть  объект/подобъект
// mode - = 0 - добавить последнюю точку
//              не добавляет, если объект замкнут
//        = 1 - заменить последнюю точку
//        = 2 - заменить первую точку
//        = 3 - добавить последнюю точку
//        = 4 - добавить первую точку
// возврат - 1 - замкнут
// При ошибке возвращает 0
int _fastcall infoAbridge(TObjectInfo *info, int number, int mode);

// Добавить в конец метрики объекта точку
// subject - номер подобъекта (если = 0, обрабатывается объект)
// Значение координат задано в метрах на местности
// Для изменения координаты Н необходимо далее
// выполнить функцию HPlane(...)
// При ошибке возвращает ноль
int _fastcall infoAppendPointPlane(TObjectInfo *info, double *x,double *y,int subject);

// Удалить из объекта точку
// subject - номер подобъекта (если = 0, обрабатывается объект)
// Значение координат задано в метрах на местности
// Для изменения координаты Н необходимо далее
// выполнить функцию HPlane(...)
// При ошибке возвращает ноль
int _fastcall infoDeletePoint(TObjectInfo *info,int number,int subject);

// Обновить точку
// subject - номер подобъекта (если = 0, обрабатывается объект)
// Значение координат задано в метрах на местности
// Для изменения координаты Н необходимо далее
// выполнить функцию HPlane(...)
// При ошибке возвращает ноль
int _fastcall infoUpdatePointPlane3D(TObjectInfo *info,
              double *x,double *y,double *h,int number,int subject);

// Редактирование координаты X точки объекта в прямоугольной системе
// в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoSetXPlane(TObjectInfo *info,
                            double *x, int number, int subject);

// Редактирование координаты Y точки объекта в прямоугольной системе
// в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoSetYPlane(TObjectInfo *info,
                            double *y, int number, int subject);

// Редактирование координаты H точки объекта в прямоугольной системе
// в метрах на местности
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoSetHPlane(TObjectInfo *info,
                            double *h, int number,int subject);

// Переформировать объект (подобъект), установив первой заданную точку
// number - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoSetFirstPoint(TObjectInfo* info, int number, int subject);  //20/10/04

// Вычисление периметра объекта
// При ошибке возвращает 0
// Вычисление периметра объекта
// При ошибке возвращает 0
double _fastcall infoPerimeter(TObjectInfo *info);

// Вычисление длины объекта на местности
// Для подобъектов считается суммарная длина
// При ошибке возвращает 0
double _fastcall infoLength(TObjectInfo *info);

// Вычисление длины объекта на карте         // 23/06/07
// Для подобъектов считается суммарная длина
// При ошибке возвращает 0
double _fastcall infoLengthInMap(TObjectInfo *info);

// Вычисление длины объекта в проекции карты
// Для подобъектов считается суммарная длина
// При ошибке возвращает 0
double _fastcall infoViewLength(TObjectInfo *info);

// Запросить - имеет ли объект графическое описание
int _fastcall infoIsDrawObject(TObjectInfo *info);

// Запросить количество элементов графического описания
// При ошибке возвращает 0
int _fastcall infoDrawCount(TObjectInfo *info);

// Запросить вид элемента графического описания
// по его номеру ( от 1 до DrawCount())
// Возвращает номер функции типа IMG_XXXXXXX (см. MAPGDI.H)
// При ошибке возвращает 0
int _fastcall infoDrawImage(TObjectInfo *info, int number);

// Запросить адрес параметров элемента графического описания
// по его номеру ( от 1 до DrawCount())
// Возвращает адрес структуры типа IMGXXXXXX, в соответствии
// с видом элемента (см. MAPGDI.H)
// Для запроса с 0 номером возвращает адрес параметров
// графического описания объекта структуры IMGDRAW
// При ошибке возвращает 0
char *_fastcall infoDrawParameters(TObjectInfo *info, int number);

// Запросить длину параметров элемента графического описания
// по его номеру ( от 1 до DrawCount())
// Для запроса с 0 номером возвращает длину параметров       // 23/10/02
// графического описания объекта
// При ошибке возвращает 0
int _fastcall infoDrawLength(TObjectInfo *info, int number);

// Добавить элемент графического описания объектов
// При ошибке возвращает ноль,иначе - число элементов в записи
int _fastcall infoAppendDraw(TObjectInfo *info,
                             int image,const char *parm);

// Удалить все элементы графического описания объекта
void _fastcall infoClearDraw(TObjectInfo *info);

// Удалить элемент графического описания объекта
// number - номер элемента (начиная с 1)
// При ошибке возвращает ноль
int _fastcall infoDeleteDraw(TObjectInfo *info, int number);

//  Выделить память для создания нового объекта
//  Проинициализировать записи справочных данных,
//  метрики и семантики
//  При ошибке возвращает 0
int _fastcall infoCreateObject(TObjectInfo *info,int kind,int text);

//  Проинициализировать запись справочных данных
//  При ошибке возвращает 0
int _fastcall infoCreateDesc(TObjectInfo * data);

//  Создать полную копию описания произвольного объекта
//  Объект может не иметь метрических (точечный) и семантических данных
//  Предыдущее описание автоматически удаляется
int _fastcall infoCopyData(TObjectInfo * infodata,
                           TObjectHead * head, OBJECTDATA * data,
                           SEMANTIC * semn, IMGDRAW * draw);

//  Удалить размещенные данные
//  Освобождает память, отведенную под хранение данных
//  Обнуляет "указатели"
void _fastcall infoDeleteData(TObjectInfo * data);

//  Проинициализировать запись метрики
//  При ошибке возвращает 0
int _fastcall infoCreateData(TObjectInfo *info,int kind,int text);

//  Проинициализировать запись семантики
//  При ошибке возвращает 0
int _fastcall infoCreateSemn(TObjectInfo *info);

//  Проинициализировать запись графического описания объекта
//  При ошибке возвращает 0
int _fastcall infoCreateDraw(TObjectInfo *info);

//  Запросить уникальный номер объекта
//  При ошибке возвращает  0
long int _fastcall infoObjectKey(TObjectInfo *info);

//  Запросить характер локализации объекта
//  При ошибке возвращает 0
int _fastcall infoObjectLocal(TObjectInfo *info);

//  Запросить условное название объекта
//  При ошибке возвращает адрес пустой строки
const char *_fastcall infoObjectName(TObjectInfo *info);

//  Запросить максимальный размер условного названия объекта
//  При ошибке возвращает ноль
int infoObjectNameSize();

//  Запросить номер слоя объекта
int _fastcall infoSegmentNumber(TObjectInfo *info);

//  Запросить название слоя объекта ("Layer" = "Segment")
//  При ошибке возвращает адрес пустой строки
const char *_fastcall infoSegmentName(TObjectInfo *info);

//  Запросить максимальный размер названия слоя объекта ("Layer" = "Segment")
//  При ошибке возвращает ноль
int infoSegmentNameSize();

//  Запросить условное название
//  характера локализации
//  При ошибке возвращает адрес пустой строки
const char *_fastcall infoLocalName(TObjectInfo *info,
                                    int local,int language);

//  Запросить максимальный размер условного названия
//  характера локализации
//  При ошибке возвращает ноль
int infoLocalNameSize();

//  Запросить число семантических характеристик у объекта
int _fastcall infoSemanticAmount(TObjectInfo *info);

//  Запросить значение семантической характеристики объекта
//  Значение преобразуется в символьный вид
//  number - последовательный номер характеристики,
//  place - адрес размещения строки,
//  maxsize - максимальная длина строки
//  При ошибке возвращает ноль,
//  при успешном выполнении - адрес строки (равен place)
char *_fastcall infoSemanticValue(TObjectInfo *info,
                                  int number,char * place,int maxsize);

// Запросить значение семантической характеристики объекта
// в виде числа с плавающей точкой двойной точности
// number  - последовательный номер характеристики
// Если значение семантики не может быть преобразовано
// к числовому виду или - возвращает ноль
double _fastcall infoSemanticDoubleValue(TObjectInfo *info, int number);

//  Запросить название семантической характеристики объекта
//  При ошибке возвращает адрес пустой строки
const char *_fastcall infoSemanticName(TObjectInfo *info, int number);

// Вычисление площади объекта
// При ошибке возвращает 0
double _fastcall infoSquare(TObjectInfo *info, int dontreal = 0);

//  Обновить значение координат точки
int _fastcall infoUpdatePointPlane(TObjectInfo * info,
                             double *x, double *y, int number, int subject);

//  Сместить все координаты метрики объекта на заданную
//  величину (delta) в метрах на местности
//  При ошибке возвращает 0
int _fastcall infoRelocateObject(TObjectInfo * info, DOUBLEPOINT * delta);

//  Вставить в метрику объекта точку
//  number - номер точки за которой будет добавлена новая точка
//  subject - номер подобъекта (если = 0, обрабатывается объект)
//  Значение координат задано в метрах на местности
//  Для изменения координаты Н необходимо далее
//  выполнить функцию HPlane(...)
//  При ошибке возвращает ноль
int _fastcall infoInsertPointPlane(TObjectInfo * info,
                             double *x,double *y,int number,int subject);

// Добавить в конец метрики объекта точку
// subject - номер подобъекта (если = 0, обрабатывается объект)
// Значение координат задано в радианах
// При ошибке возвращает ноль
int _fastcall infoAppendPointGeo(TObjectInfo * info,
                                 double *b,double *l,int subject);

// Вставить в метрику объекта точку
// number - номер точки за которой будет добавлена новая точка
// subject - номер подобъекта (если = 0, обрабатывается объект)
// Значение координат задано в радианах
// Для изменения координаты Н необходимо далее
// выполнить функцию HPlane(...)
// При ошибке возвращает ноль
int _fastcall infoInsertPointGeo(TObjectInfo * info,
                             double *b,double *l,int number,int subject);

// Изменить координаты точки метрики
// Значение координат задано в радианах
// number  - номер точки
// subject - номер подобъекта (если = 0, обрабатывается объект)
// При ошибке возвращает ноль
int _fastcall infoUpdatePointGeo(TObjectInfo * info,
                             double *b,double *l,int number,int subject);

int _fastcall infoUpdatePointGeo3D(TObjectInfo * info,double *b,double *l,
                                   double * h,int number,int subject);

// Установить значение координат в метрах на местности
// Размерность метрики в data берется из Desc
// Тип метрики в data IDDOUBLE
// При ошибке возвращает ноль
int _fastcall infoPutDataPlane(TObjectInfo * info,DATAEDIT * data);

// Запросить значение координат в метрах на местности
// Обновляет метрику Data из data
// Размерность метрики в Data берется из data,
// Тип метрики в Data сохраняется (но не ниже IDFLOAT)
// При ошибке возвращает ноль
int _fastcall infoGetDataPlane(TObjectInfo * info, TDataEdit *data);

// Установить значение координат в радианах
// Размерность метрики в data берется из Desc
// Тип метрики в data IDDOUBLE
// При ошибке возвращает ноль
int _fastcall infoPutDataGeo(TObjectInfo * info,DATAEDIT * data);

// Запросить значение координат в радианах
// Обновляет метрику info.Data из data
// Размерность метрики в info.Data берется из data,
// Тип метрики в info.Data сохраняется (но не ниже IDFLOAT)
// При ошибке возвращает ноль
int _fastcall infoGetDataGeo(TObjectInfo * info, TObjectInfo * data);

// Повернуть объект вокруг заданного в прямоугольной
// системе X,Y в м. центра ( center )
// на заданный угол ( anglevalue ).
// Угол задается в радианах и может принимать значения:
// от 0 до PI и от 0 до -PI или
// от 0 до PI и от 0 до 2PI
// При ошибке возвращает 0
int _fastcall infoRotateObject(TObjectInfo * info,
                               DOUBLEPOINT *center,double *anglevalue);

// Масштабировать(factor) метрику объекта
// factor - коэффициент
// deltanull - смещение относительно 0
// При ошибке возвращает ноль
int _fastcall infoScopeObject(TObjectInfo *info,
                              DOUBLEPOINT *factor,DOUBLEPOINT *deltanull);

// Масштабировать (factor) и cместить все координаты метрики
// объекта на заданную величину (delta)
// factor - коэффициент
// deltanull - смещение относительно 0
// delta - непосредственно смещение
// При ошибке возвращает ноль
int _fastcall infoScopeAndRelocateObject(TObjectInfo * info,
                           DOUBLEPOINT *factor,DOUBLEPOINT *deltanull,
                           DOUBLEPOINT *delta);


//  Обновить данные о групповом объекта в файле
//  Номер листа в районе и номер объекта должен быть установлен
//  При ошибке возвращает ноль
int _fastcall infoCommitGroup(TObjectInfo * info, int semn, int draw);


// Запросить - растягивается ли объект по метрике
int _fastcall infoIsObjectStretch(TObjectInfo *info);

// Масштабируемость объекта
//  23/04/03
int _fastcall infoScale(TObjectInfo *info, const int scale);

// Сжимаемость объекта
//  24/02/05
int _fastcall infoPress(TObjectInfo *info, const int press);


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++  Описание структуры для создания символьной строки - формулы +++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
typedef struct STRINGPART
{
  unsigned long Code;        // Код основной семантики
  unsigned long ReserveCode; // Код резервной семантики или 0
  unsigned long Place;       // Место вставки
  unsigned long ReplaceSize; // Количество замещаемых символов
  char DefaultString[128];   // Умалчиваемая строка
}
  STRINGPART;


 // ***********************************************************************
 //  Класс TStringFormula - Создание символьной строки по форматированной *
 //  строке с учетом значений семантики объекта                           *
 // формат строки: после %# идет номер семантики, за ним в []- значение,  *
 // которое будет вставлено в строку при отсутствии указанной семантики   *
 // остальной текст в произвольной форме.                                 *
 // Пример:входная строка - "дом Э %#45[нет] сост. %#3[не заполнено]"     *
 //     результат по значениям семантики для конкретного объекта          *
 //     "дом Э 5 сост. не заполнено" или "дом Э 7-a сост. ЖИЛОЙ"          *
 //      или  "дом Э нет сост. не заполнено"                              *
 // ***********************************************************************
class _DLLCLASS TStringFormula
{
public:

  TStringFormula();
  ~TStringFormula(){};

  //Очистка структур
  void _fastcall Clear();                // 10/03/07

  //  Загрузить формулу
  //  При ошибке возвращает 0
  int _fastcall LoadFormString(const char * string);

  //  Собрать строку-результат по семантикам объекта
  //  info - объект по семантикам которого ведется вычисление
  //  string - строка для записи результата
  //  size - размер результирующей строки
  //  При ошибке возвращает 0

  int _fastcall BuildString(HOBJ info,char * string,int size);

public :

  STRINGPART Parts[32];         // Массив структур для разбора строки
  long       Count;             // Количество заполненных структур
  char       Source[MAX_PATH];  // Входная строка    // 10/03/07
};

#endif
