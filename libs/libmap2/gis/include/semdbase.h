#if !defined(SemDbase_H)
#define SemDbase_H

#ifndef MAPAPI_H
#include "mapapi.h"
#endif

//#pragma pack(1)

typedef struct CELLFORMAT  // ОПИСАНИЕ ПОЛЯ ЗАПИСИ БД
{
  LONG Length;         // Размер структуры sizeof(CELLFORMAT)
  LONG  Code;           // Код семантики
  char     Name[32];       // Имя поля
  LONG Type;           // Тип поля
                           //  - специальные типы (используются
                           // только при вызове функции
                           // sdbAppendRecordForObject)
                           // ('N'- числовое,
                           //  'C'- символьное,
                           //  'E'- внешний код объекта карты = N 10.0,
                           //  'O'- уникальный номер объекта  = N 10.0,
                           //  'S'- название листа объекта    = C 24,
                           //  'U'- текущий номер записи      = N 5.0
                           //  'D'- если значение семантической характеристики 
                           //  объекта представлено в символьном раскодированном виде)
                           //  'A'- неизвестный тип поля(при считывании формата
                           //       записи таблицы в массив)
 LONG  Size;            // Размер поля
 LONG  Form;            // Формат числа (точность представления)
}
  CELLFORMAT;

typedef struct SEMLAYCREATE    // Cтруктура параметров создания таблицы
{
    LONG  Length;           // Размер структуры
    LONG  Layer;            // Номер слоя
    LONG  Local;            // Тип локализации или -1,если любая локализация
    LONG  EmptyRec;         // =0/1 - пустые записи не создавать/создавать
    LONG  Decode;           // =0/1 - семантику не раскодировать/раскодировать
    char     TableName[256];   // Полное имя таблицы
    char     FieldExcode[32];  // Имя поля внешнего кода или /0
    char     FieldObject[32];  // Имя поля номера объекта или /0
    char     FieldSheet[32];   // Имя поля имени листа или /0
    char     FieldRecN[32];    // Имя поля номера текущей записи или /0
}
  SEMLAYCREATE;

typedef struct STLOCATE        // Описание массива для навигации по locate
{  
   char     NameField[32];     // Имя поля
   LONG  CodSem;            // Код семантики(если есть код семантики, то имя поля 
                               // игнорируется и определяется по CodSem)
   char     ValueField[256];   // Значение 
 }

STLOCATE;

typedef struct STNAMEFIELD     // Описание массива имен и типов полей
{
    LONG  NumbField;        // Номер поля
    char     NameField[32];    // Имя поля
    LONG  TypeField;        // Тип поля ('N'- числовое,
                               //           'C'- символьное,
                               //           'A'- неизвестный тип поля)
 }
STNameField;

//#pragma pack()


typedef long int HSEMDB  ;     // Идентификатор открытой таблицы

typedef long int HRSCDB  ;     // Идентификатор объекта
                               // сохранения семантики в таблицу
 enum DBASEEERRORTYPE               
  {
    DB_REPEATCODESEM    = 2,    // в массиве повторяется код семантики,
    DB_REPEATNAMEFIELD  = 3,    // в массиве повторяется имя поля,
    DB_IMPOSTYPEFIELD   = 4,    // в массиве недопустимый тип поля,
    DB_IMPOSPRESFIELD   = 5,    // в массиве недопустимая точность поля
    DB_FILEABSENT       = 6,    // исходный файл не существует
    DB_ERSIZEARRAY      = 7,    // размер массива не соответствует заданному,
    DB_ERSIZESTRCELLF   = 8,    // не совпадает размер структуры sizeof(CELLFORMAT),
    DB_VALUEIDENTZERO   = 9,    // значение идентификатора  =0
    DB_ABSENTOPENTABLE  = 10,   // нет открытой таблицы
    DB_COMERRORSEM      = 11,   // общие ошибки при обработки семантики объкта
    DB_ERREADSEM        = 12,   // ошибка чтения семантики объекта
    DB_ERSAVENUMREC     = 13,   // ошибка сохранения номера текущей записи
    DB_IMPOSCODSEM      = 14,   // невозможно определить код семантики у объекта
    DB_IMPOSOPENTABLE   = 15,   // невозможно открыть таблицу
    DB_ERNAMETABLE      = 16,   // имя поля таблицы задано не верно
    DB_IMPOSTYPFIELD    = 17,   // недопустимый тип поля
    DB_ABSENTVALUEFIELD = 18,   // нет значений в поле
    DB_ERSHORTNAMESEM   = 19,   // короткое название сематики превышает 10 символов
    DB_ERRECORDCOUNT    = 20,   // кол-во записей в таблице =0
    DB_ERRFIRSTSIMBOL   = 21,   // недопустимый первый символ в имени поля
    DB_ERRFIELDNAME     = 22,   // имя поля задано ключевым словом
    DB_IDENTMAPZERO     = 30,   // идентификатор карты =0
    DB_IDENTRSCNOTFOUND = 31,   // идентификатор Rsc не найден
    DB_REPEATOPENTABL   = 32,   // класс уже проинициализирован и таблица открыта
    DB_ABSENTVALSEMLAYER= 33,   // нет семантики для нужного слоя (=0)
    DB_ERCOUNTSEMLAYRSC = 34,   // ошибка в количестве семантик слоя в RSC
    DB_ERTYPESEMRSC     = 35,   // ошибка при определении типа семантики по RSC
    DB_ERSERVISABSENT   = 36,   // нет доступа к сервису из-за предыдущих ошибок
    DB_IMPOSDELOLDTABLE = 37,   // невозможно удалить старый файл таблицы
    DB_ERSIZENUMLAYERLOC= 38,   // номер слоя или локализации больше допустимого
    DB_ABSREGLAYERLOC   = 40,   // нет требуемого зарегестрированного слоя и локализации
    DB_NOUNREPREGISTAB  = 41,   // отказ в повторной регистрации таблицы
    DB_UNDERSINPUTPARAM = 98,   // непонятны входные параметры
    DB_SYSTEMERROR      = 99,   // системная ошибка(память и т.п.)
  };

extern "C"
{

// Получить код ошибки
// handle - идентификатор таблицы .
// Если ошибки нет возвращает ноль, иначе :
//   2  - в массиве повторяется код семантики,
//   3  - в массиве повторяется имя поля,
//   4  - в массиве недопустимый тип поля,
//   5  - в массиве недопустимая точность поля,
//   6  - исходный файл не существует,
//   7  - размер массива не соответствует заданному,
//   8  - не совпадает размер структуры sizeof(CELLFORMAT),
//   9  - значение идентификатора  =0
//   10 - нет открытой таблицы
//   11 - общие ошибки при обработки семантики объкта
//   12 - ошибка чтения семантики объекта
//   13 - ошибка сохранения номера текущей записи
//   14 - невозможно определить код семантики у объекта
//   15 - невозможно открыть таблицу
//   16 - имя поля таблицы задано не верно(имя должно состоять из 10 символов или меньше,
//         первый символ - буква. Использовать только A-Z,0-9 или _, не использовать букву ч)
//   17 - недопустимый тип поля
//   18 - нет значений в поле
//   19 - короткое название сематики превышает 10 символов
//   20 - кол-во записей в таблице =0
//   21 - недопустимый первый символ в имени поля (0-9,_,Ч)
//   22 - имя поля задано ключевым словом
//   30 - идентификатор карты =0
//   31 - идентификатор Rsc не найден
//   32 - класс уже проинициализирован и таблица открыта
//   33 - нет семантики для нужного слоя (=0)
//   34 - ошибка в количестве семантик слоя в RSC
//   35 - ошибка при определении типа семантики по RSC
//   36 - нет доступа к сервису из-за предыдущих ошибок
//   37 - невозможно удалить старый файл таблицы
//   38 - номер слоя или локализации больше допустимого
//   40 - нет требуемого зарегестрированного слоя и локализации
//   41 - отказ в повторной регистрации таблицы
//   99 - системная ошибка(память и т.п.)
//   98 - непонятны входные параметры
 long int WINAPI sdbErrorCode(HSEMDB handle);


// Получить сообщениe об ошибке по коду ошибки
// ErrCode  - код ошибки.
// Возвращает сообщение об ошибке.
  char * WINAPI GetErrorText(long int ErrCode);


// Получить расширенное сообщение об ошибке
// (для ошибки DB_ERSHORTNAMESEM добавляется короткое название сематики)
// handle - идентификатор таблицы
// Возвращает сообщение об ошибке.
  const char * WINAPI sdbErrorTextEx(HSEMDB handle);


// Функция контроля и заполнения массива описания структуры CELLFORMAT 
// по заданным кодам семантики (если код=0, то осуществляется контроль
// имен на наличие дубликатов и длину) 
// fMap   - идентификатор открытой векторной карты
// fSite  - идентификатор открытой пользовательской  карты
// format - массив описания полей таблицы,
// count  - размер массива,
// Decode - 0/1 - семантику не раскодировать/раскодировать
// При ошибке возвращает ноль и код ошибки errCode , иначе - 1-заполненную  структуру. 
long int WINAPI ControlTableStruct(HMAP hMap,HSITE hSite,CELLFORMAT*format, long int count,long int decode,long int*errCode);

// Функция контроля новой записи массива описания структуры CELLFORMAT 
// (проверка имени,типа,размера)
// newrec - новая запись
// format - массив описания полей таблицы (для проверки на дубликат имен),
// count  - размер массива,
// При ошибке возвращает ноль и код ошибки errCode , иначе - 1.             
long int WINAPI ControlNewRecordForTableStruct(CELLFORMAT*newrec,CELLFORMAT*format,long int count,long int*errCode);
                                           
// Получить идентификатор таблицы, задать структуру таблицы из
// текстового файла, создать таблицу, открыть таблицу
// text   - имя текстового файла,
// table - имя создаваемой таблицы.
// При ошибке возвращает ноль, иначе - идентификатор открытой
// таблицы базы данных. Открытая таблица обязательно должна быть
// закрыта в конце работы вызовом функции sdbCloseTable.
 HSEMDB WINAPI sdbCreateTableFromFile(const char*text,const char*table);

// Получить идентификатор таблицы, задать структуру таблицы
// из массива, создать таблицу, открыть таблицу
// CELLFORMAT - массив описания полей таблицы,
// count - размер массива,
// table - имя создаваемой таблицы.
// При ошибке возвращает ноль, иначе - идентификатор открытой
// таблицы базы данных. Открытая таблица обязательно должна быть
// закрыта в конце работы вызовом функции sdbCloseTable.
 HSEMDB WINAPI sdbCreateTableFromArray(CELLFORMAT*format, long int count,
                                       const char* table);
// Получить идентификатор таблицы, открыть таблицу c проверкой соответствия структуры 
//(все поля объявленные в структуре должны существовать в открываемой таблице).
// table - имя таблицы.
// При ошибке возвращает ноль, иначе - идентификатор открытой
// таблицы базы данных. Открытая таблица обязательно должна быть
// закрыта в конце работы вызовом функции sdbCloseTable.
 HSEMDB WINAPI sdbOpenAndCheckTable(const char* table);

// Получить идентификатор таблицы, открыть таблицу без проверки соответствия структуры
// table - имя таблицы.
// При ошибке возвращает ноль, иначе - идентификатор открытой
// таблицы базы данных. Открытая таблица обязательно должна быть
// закрыта в конце работы вызовом функции sdbCloseTable.
 HSEMDB WINAPI sdbOpenAndNotCheckTable(const char* table);

// Добавить новую пустую запись
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль.
 long int WINAPI sdbAppendRecord(HSEMDB handle);    

// Удалить текущую запись
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль.
 long int WINAPI sdbDeleteRecord(HSEMDB handle);

// Запись значения семантики в текущую запись по коду семантики
// handle  - идентификатор открытой таблицы,
// code  - код семантики,
// value - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbSaveSemanticInRecord(HSEMDB handle,long int code,
                                         const char* value);

// Запись значения семантики в текущую запись по имени поля
// handle  - идентификатор открытой таблицы,
// name    - имя поля,
// value   - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbSaveSemanticByField(HSEMDB handle,char* name,
                                        const char* value);

// Добавить запись для объекта
// handle   - идентификатор открытой таблицы,
// hObj     - указатель на объект карты,
// EmptyRec - =0/1 - пустые записи не создавать/создавать,
// Decode   - =0/1 - семантику не раскодировать/раскодировать.
// При ошибке возвращает ноль.
 long int WINAPI sdbAppendRecordForObject(HSEMDB handle,HOBJ hObj, long int EmptyRec,long int Decode);


// Сохранить изменения в записи
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль.
 long int WINAPI sdbPostRecord(HSEMDB handle);

// Получить количество записей
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль. 
 long int WINAPI sdbGetTableRecordCount(HSEMDB handle);

// Получить количество полей
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль. 
 long int WINAPI sdbGetTableFieldCount(HSEMDB handle);

// Перейти на первую запись таблицы
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает 0. 
 long int WINAPI sdbGotoFirst(HSEMDB handle);

// Перейти на следующую запись таблицы
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает 0. 
 long int WINAPI sdbGotoNext(HSEMDB handle);

// Перейти на предыдущую запись таблицы
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает 0. 
 long int WINAPI sdbGotoPrior(HSEMDB handle);

// Перейти на последнюю запись таблицы
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает 0. 
 long int WINAPI sdbGotoLast(HSEMDB handle);

// Получить min integer значение по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - min integer значение.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetMinIntegerValueByNameField(HSEMDB handle,char* name,long int* valuesem);

// Получить max integer значение по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - max integer значение.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetMaxIntegerValueByNameField(HSEMDB handle,char* name,long int* valuesem);

// Получить min double значение по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - min double значение.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetMinDoubleValueByNameField(HSEMDB handle,char* name,double* valuesem);

// Получить max double значение по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - max double значение.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetMaxDoubleValueByNameField(HSEMDB handle,char* name,double* valuesem);

// Сосчитать формат записи в массив  структур CELLFORMAT
// handle  - идентификатор открытой таблицы,
// format  - массив описания полей таблицы,
// count   - размер массива.
// При ошибке возвращает ноль, иначе
//         - 1 - массив заполнен
//         - 2 - массив заполнен, но есть поля с неизвестным типом
 long int WINAPI sdbGetTableStruct(HSEMDB handle,CELLFORMAT*format, long int count);

// Обновить массив  структур CELLFORMAT с контролем имен
// handle  - идентификатор открытой таблицы,
// format  - массив описания полей таблицы,
// count   - размер массива.
// При ошибке возвращает ноль, иначе
//         - 1 - массив заполнен
//         - 2 - массив заполнен, но есть поля с неизвестным типом
 long int WINAPI sdbUpdateCodeSemantic(HSEMDB handle,CELLFORMAT*format, long int count);

// Получить название поля и его тип по номеру поля
// handle      - идентификатор открытой таблицы,
// stnamefield - массив имен и типов полей(необходимо задать в массиве номера полей 
//               по которым осуществляется поиск),
// count - размер массива.
// При ошибке возвращает ноль, иначе
//             - 1 - массив заполнен.
 long int WINAPI sdbGetNameAndTypeFieldByNumberField(HSEMDB handle,STNAMEFIELD * stnamefield, long int count);

// Получить массив значений , используя массив имен полей
// handle   - идентификатор открытой таблицы,
// stlocate - массив с именами полей (значения не задаются),
// count   - размер массива.
// При ошибке возвращает 0, иначе 
//         - 1 - массив заполнен значениями из текущей записи.
 long int  WINAPI sdbGotoLocateRecord(HSEMDB handle,STLOCATE * stlocate, long int count);

// Поиск записи с помощью  Locate, используя массив полей и значений
// (задается имя поля и его значение для поиска)
//(можно задать до 5 полей)
// handle   - идентификатор открытой таблицы,
// stlocate - массив для поиска,
// count   - размер массива.
// При ошибке возвращает 0, иначе 
//         - 1 - указатель текущей записи установлен на требуемую запись
//(если записей несколько, то на первую из них).
 long int  WINAPI sdbTableLocate(HSEMDB handle,STLOCATE * stlocate, long int count);

// Сосчитать данные  в виде символьного  значения по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// count    - длина строки valuesem,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticByFieldChar(HSEMDB handle,char* name,long int count,char* valuesem);

//Сосчитать данные  в виде символьного  значения по коду семантитки
// handle   - идентификатор открытой таблицы,
// codsem   - код семантики,
// count    - длина строки valuesem,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticInRecordChar(HSEMDB handle,long int codsem,long int count,char* valuesem);


//Сосчитать данные  в виде integer по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticByFieldInt(HSEMDB handle,char* name,long int* valuesem);

//Сосчитать данные  в виде integer по коду семантитки
// handle   - идентификатор открытой таблицы,
// codsem   - код семантики,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticInRecordInt(HSEMDB handle,long int codsem,long int* valuesem);

//Сосчитать данные  в виде double по имени поля
// handle   - идентификатор открытой таблицы,
// name     - имя поля,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticByFieldDouble(HSEMDB handle,char* name,double* valuesem);

//Сосчитать данные  в виде double по коду семантитки
// handle   - идентификатор открытой таблицы,
// codsem   - код семантики,
// valuesem - значение семантики.
// При ошибке возвращает ноль.
 long int WINAPI sdbGetSemanticInRecordDouble(HSEMDB handle,long int codsem,double* valuesem);

// Отменить изменения в текущей записи
// (отмена изменений возможна, если не вызывалась функция sdbPostRecord)
// handle  - идентификатор открытой таблицы.
// При ошибке возвращает ноль.
 long int WINAPI sdbTableCancel(HSEMDB handle);

// Закрыть таблицу
// handle  - идентификатор открытой таблицы.
 void WINAPI sdbCloseTable(HSEMDB handle);

/************************************************************
*                                                           *
* ФУНКЦИИ МЕНЕДЖЕРА АВТОМАТИЧЕСКОГО СОЗДАНИЯ ТАБЛИЦ ПО RSC  *
*                                                           *
************************************************************/

// Получить код ошибки
// handle - идентификатор объекта управления.
// Если ошибки нет возвращает ноль,, иначе :
//   2  - в массиве повторяется код семантики,
//   3  - в массиве повторяется имя поля,
//   4  - в массиве недопустимый тип поля,
//   5  - в массиве недопустимая точность поля,
//   6  - исходный файл не существует,
//   7  - размер массива не соответствует заданному,
//   8  - не совпадает размер структуры sizeof(CELLFORMAT),
//   9  - значение идентификатора  =0
//   10 - нет открытой таблицы
//   11 - общие ошибки при обработки семантики объкта
//   12 - ошибка чтения семантики объекта
//   13 - ошибка сохранения номера текущей записи
//   14 - невозможно определить код семантики у объекта
//   15 - невозможно открыть таблицу
//   16 - имя поля таблицы задано не верно(имя должно состоять из 10 символов или меньше,
//          первый символ - буква. Использовать только A-Z,0-9 или _, не использовать букву ч) 
//   17 - недопустимый тип поля
//   18 - нет значений в поле 
//   19 - короткое название сематики превышает 10 символов
//   20 - кол-во записей в таблице =0 
//   21 - недопустимый первый символ в имени поля
//   22 - имя поля задано ключевым словом
//   30 - идентификатор карты =0
//   31 - идентификатор Rsc не найден
//   32 - класс уже проинициализирован и таблица открыта
//   33 - нет семантики для нужного слоя (=0)
//   34 - ошибка в количестве семантик слоя в RSC
//   35 - ошибка при определении типа семантики по RSC
//   36 - нет доступа к сервису из-за предыдущих ошибок
//   37 - невозможно удалить старый файл таблицы
//   38 - номер слоя или локализации больше допустимого
//   40 - нет требуемого зарегестрированного слоя и локализации
//   41 - отказ в повторной регистрации таблицы
//   99 - системная ошибка(память и т.п.)
//   98 - непонятны входные параметры
 long int WINAPI sdrErrorCode(HRSCDB handle);


// Получить расширенное сообщение об ошибке
// (для ошибки DB_ERSHORTNAMESEM добавляется короткое название сематики)
// handle - идентификатор объекта управления.
// Возвращает сообщение об ошибке.
  const char * WINAPI sdrErrorTextExRsc(HRSCDB handle);


// Получить идентификатор таблицы для RSC
// При ошибке возвращает ноль, иначе - идентификатор объекта управления.
 HRSCDB WINAPI sdrCreateFromMap(HMAP hMap,HSITE hSite);


// Зарегистрировать слой и локализацию
// handle  - идентификатор  объекта управления.
// semlaycreate - структура параметров создания таблицы.
// При ошибке возвращает ноль.
 long int WINAPI sdrRegisterLayer(HRSCDB handle, SEMLAYCREATE * semlaycreate);


// Cохраненить  семантику объекта для зарегестрированного слоя
// handle  - идентификатор  объекта управления.
// hObj - указатель на объект карты.
// При ошибке возвращает ноль, иначе - возвращает номер записи.
 long int WINAPI sdrSaveSemanticForObject(HRSCDB handle,HOBJ hObj);

// Закрыть таблицы для RSC
// handle  - идентификатор  объекта управления.
 void WINAPI sdrClose(HRSCDB handle);



} // extern "C"

#endif

