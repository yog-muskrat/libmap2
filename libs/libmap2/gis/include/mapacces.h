
#ifndef MAPACCES_H
#define MAPACCES_H

#ifndef MAPPAINT_H
  #include "mappaint.h"
#endif

#ifndef MAPAPI_H
  #include "mapapi.h"
#endif

#ifndef HIDEMTR3D        
#ifndef MTRPAI3D_H
  #include "mtrpai3d.h"
#endif
#endif

/***************************************************************
********************  СИСТЕМЫ КООРДИНАТ ************************
****************************************************************

    Xд Xп
  ^
  | (0,0) (Начало изображения "Picture")
  +---------------------------------------------------> Xи
  |                                                 ^
  |        (Координаты окна "Client")               |
  |   (0,0)                      Xо                 |
  |     ----------------------->                    |
  |     |               |                           |
  |     |        x..... x  Окно визуализации        |
  |     |        ....A. |                           |
  |     |        ...+.. |                           |
  |     |        ...... |                         Габариты
  |     ---------x------x                    района ("Region")
  |     |          ^                                |
  |     |          |                                |
  |     |         Область текущего вывода           |
  |     V                  ("Draw")                 |
  |       Yо                                        |
  |                                                 V
  +----------------------------------------------------> Yд Yп
  |
  |  0,0 (Начало района "Map" в дискретах
  |       и "пикселах")
  |
  V        координаты т.A в районе Xд,Yд; в изображении Xи,Yи
    Yи        Xд = Pix2Dis(RegionPix.X2 - Yи);
              Yд = Pix2Dis(RegionPix.Y1 + Xи);

***************************************************************/

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ КЛАСС "ИНТЕРФЕЙС УПРАВЛЕНИЯ ЭЛЕКТРОННОЙ КАРТОЙ" ++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class _DLLCLASS  TMapAccess : public TMapPaint
{
  public:

  /*********************************************************
  *                                                        *
  *           КОНСТРУКТОРЫ И ДЕСТРУКТОРЫ КЛАССА            *
  *                                                        *
  *********************************************************/

   TMapAccess();
  ~TMapAccess();

   // Запросить версию модуля MapAccess.Dll
   // Если полученная версия не равна значению MAPACCESSVERSION
   // в работе программы может произойти сбой

   long int GetMapAccessVersion();


  /*********************************************************
  *                                                        *
  *          ОТКРЫТЬ/ЗАКРЫТЬ ДОСТУП К ДАННЫМ КАРТЫ         *
  *                                                        *
  *********************************************************/

  // Открыть данные с автоматическим определением их типа
  // При ошибке возвращает ноль

  int OpenData(const char * mapname,int mode = 0);

  // Открыть векторные данные
  // При ошибке возвращает ноль

  int OpenMap(const char * mapname,int mode = 0);

  // Открыть растровые данные
  // При ошибке возвращает ноль

  int OpenRst(const char * rstname,int mode = 0);

  // Открыть матричные данные
  // При ошибке возвращает ноль

  int OpenMtr(const char * mtrname,int mode = 0);

#ifndef HIDEMTL
  // Открыть матрицу слоев
  // При ошибке возвращает ноль

  int OpenMtl(const char * mtrname,int mode = 0);
#endif

  // Открыть TIN-модель
  // При ошибке возвращает ноль
  int OpenTin(const char * tinname,int mode = 0);  


#ifndef HIDEMTQ
  // Открыть матрицу качеств
  // При ошибке возвращает ноль

  int OpenMtq(const char * mtrname,int mode = 0);
#endif

  // Открыть карту обстановки
  // При ошибке возвращает ноль

  int OpenSit(const char * sitname,int mode = 0);

  // Открыть проект данных
  // При ошибке возвращает ноль

  int OpenMpt(const char * name);

  //  Добавить проект данных 
  int AppendMpt(const char * name);

  // Закрыть все данные электронной карты

  void CloseData();

  // Закрыть векторные данные

  void CloseMap();

  // Закрыть растровые данные
  // number - номер закрываемого растра,
  // если равен нулю - закрывает все растры

  void CloseRst(int number = 0);

  // Закрыть матричные данные
  // number - номер закрываемой матрицы
  // если равен нулю - закрывает все матрицы

  void CloseMtr(int number = 0);

  // Закрыть карту обстановки
  // number - номер закрываемой карты
  // если равен нулю - закрывает все карты обстановки

  void CloseSit(int number = 0);

  // Сохранить проект данных
  // При ошибке возвращает ноль

  int SaveMpt(const char * name);

  enum PLACE             // ПРИМЕНЯЕМАЯ СИСТЕМА КООРДИНАТ
      {
         MAP     = 1,    // КООРДИНАТЫ ТОЧЕК В СИСТЕМЕ КАРТЫ В ДИСКРЕТАХ
         PICTURE = 2,    // КООРДИНАТЫ ТОЧЕК В СИСТЕМЕ ИЗОБРАЖЕНИЯ В ПИКСЕЛАХ
         PLANE   = 3,    // КООРДИНАТЫ ТОЧЕК В ПЛОСКОЙ ПРЯМОУГОЛЬНОЙ СИСТЕМЕ
                         // НА МЕСТНОСТИ В МЕТРАХ
         GEO     = 4,    // КООРДИНАТЫ ТОЧЕК В ГЕОДЕЗИЧЕСКИХ КООРДИНАТАХ
                         // В РАДИАНАХ
      };


  // Выполнить согласование данных электронной карты
  // Если состояние данных изменилось - возвращает 1,
  // иначе 0

  int AdjustData();

  /*********************************************************
  *                                                        *
  *    ФУНКЦИИ ОТОБРАЖЕНИЯ И ПЕЧАТИ ЭЛЕКТРОННОЙ КАРТЫ      *
  *  ПАРАМЕТРЫ КОНТЕКСТА ПОДГОТОВЛЕНЫ (HDC) И УСТАНОВЛЕНО  *
  *  СМЕЩЕНИЕ НА ОБЛАСТЬ ВЫВОДА В ОКНЕ ::SetViewportOrgEx()*
  *                                                        *
  *********************************************************/

 // Отобразить фрагмент карты на заданном устройстве
 // в текущих масштабе и составе объектов
 // hdc   - идентификатор контекста устройства вывода,
 // erase - признак стирания фона перед выводом,
 // (0 - фон не стирать, !=0 - очистить фрагмент цветом фона)
 // rect  - координаты фрагмента карты (Draw)
 // в изображении (Picture).
 // С изображениями больше 32000х32000 работает только
 // под Windows NT (Windows 95 имеет 16-битовую графику)

  void _fastcall Paint(HDC hdc, int erase, RECT& rect);

 // Отобразить фрагмент карты на заданном устройстве
 // в текущих масштабе и составе объектов
 // rect - координаты фрагмента карты (Draw) в изображении (Picture)
 // Корректно работает с большими изображениями под Windows95 и NT,
 // но требует перед вызовом установки
 //              ::SetViewportOrgEx(hDC, dx , dy, 0),
 // где dx,dy - положение отображаемого фрагмента в клиентной
 // области !

  void _fastcall Paint95(HDC hDC, int erase, RECT& rect);

 // Отобразить фрагмент карты на заданном устройстве
 // в текущих масштабе и составе объектов и
 // выделить на карте объекты, удовлетворющие заданным условим
 // hMap   - идентификатор открытых данных
 // hdc    - контекст устройства
 // rect   - координаты фрагмента карты (Draw) в изображении (Picture)
 // select - условия отбора объектов
 // color  - цвет, которым будут выделяться объекты на карте

  void _fastcall Paint95AndSelect(HDC hDC, int erase, RECT& rect,
                                  TMapSelect * select, COLORREF color);  

#ifndef LINUXAPI  
 // Отобразить фрагмент карты на заданном устройстве с учетом калибровки
 // в текущих масштабе и составе объектов
 // rect - координаты фрагмента карты (Draw) в изображении (Picture)
 // parm - параметры печати (описание PRINTPARM см. prnapi.h)

 void _fastcall Print(HDC hDC, RECT& rect, PRINTPARM* parm);                  
#endif

 // Отобразить отдельный объект карты в пределах фрагмента
 // в условных знаках карты
 // Может использоваться для вывода шаблонов объектов
 // Координаты объекта заданы в дискретах в листе
 // С изображениями больше 32000х32000 работает только
 // под Windows NT (Windows 95 имеет 16-битовую графику)
 // При ошибке в параметрах возвращает ноль

  int _fastcall PaintObject(HDC hdc, RECT& rect, TObjectInfo * object,
                            int erase=1, int dontclip=0);

  int _fastcall PaintObject95(HDC hdc, RECT& rect, TObjectInfo * object)
  {
    return PaintObject95(hdc, 1, rect, object);
  }

  int _fastcall PaintObject95(HDC hdc, int erase, RECT& rect,
                              TObjectInfo * object);

 // Отобразить произвольный объект в пределах фрагмента
 // в условных знаках пользователя
 // image - описание вида объекта (см. MAPGDI.H),
 // Координаты объекта заданы в дискретах в листе
 // При ошибке в параметрах возвращает ноль

  int _fastcall PaintMapObject95(HDC hdc, RECT& rect,
                                 PAINTPARM * image,
                                 TObjectInfo * info)
  {
    return PaintMapObject(hdc, rect, image, info, 0);
  }


 // Отобразить произвольный объект в пределах фрагмента
 // в условных знаках пользователя
 // rect - координаты фрагмента карты (Draw) в изображении (Picture)
 // image - описание вида объекта (см. MAPGDI.H),
 // offset - смещение координат объекта (в соответствии с place)
 // Координаты объекта заданы в дискретах в листе
 // При ошибке в параметрах возвращает ноль

  int _fastcall PaintOffsetMapObject95(HDC hdc, RECT& rect,
                                       PAINTPARM * image, TObjectInfo * object,
                                       DOUBLEPOINT& offset,
                                       int place);

#ifdef WIN32API
 // Вывести изображение карты в DIB
 // Выводится фрагмент карты, заданный параметром rect.

  int PaintToDib(BITMAPINFOHEADER * dibinfo,
                 char * lpDibBits,RECT& rect);

 // Вывести изображение карты в DIB
 // Выводится фрагмент карты, заданный параметром rect.
 // Заполняется палитра,расположенная за BITMAINFOHEADER
 // Изображение строится в текущем масштабе и составе объектов
 // Палитра DIB только 256 цветов, размер точки 1 байт !
 // Если размеры заданного DIB меньше размеров фрагмента -
 // изображение строится в пределах размеров DIB.
 // lpDibBits - адрес первого байта битовой области.
 // При ошибке в параметрах возвращает ноль

  int PaintToDib256(BITMAPINFOHEADER * dibinfo,
                    char * lpDibBits, RECT& rect);

  // Построить палитру для 8-битного изображения

  void BuildPalette256(RGBQUAD * palette);              

 // Вывести изображение карты в DIB          
 // Только для платформы Windows
 // Выводится фрагмент карты, заданный параметром rect.
 // Палитра DIB только GrayScale (256 оттенков серого), размер точки 1 байт !
 // Если размеры заданного DIB меньше размеров фрагмента -
 // изображение строится в пределах размеров DIB.
 // lpDibBits - адрес первого байта области изображения.
 // При ошибке в параметрах возвращает ноль
 //
 // !!! В экранном режиме не првильно отображаются заливки площадных !!!
 //
 int PaintToDibGrayScale(BITMAPINFOHEADER * dibinfo,
                          char * lpDibBits, RECT& rect);

  //  Вывести изображение карты в DIB  
  //  Только для платформы Windows
  //  Выводится фрагмент карты, заданный параметром rect.
  //  Изображение строится в текущем масштабе и составе объектов
  //  Палитра DIB только 2 цвета, размер точки 1 бит !
  //  (Все, что отображается не белым, записывается черным!!!)
  //  Если размеры заданного DIB меньше размеров фрагмента -
  //  изображение строится в пределах размеров DIB.
  //  lpDibBits - адрес первого байта области изображения.
  //  При ошибке в параметрах возвращает ноль

  int PaintToDib_1(BITMAPINFOHEADER * dibinfo,
                   char * lpDibBits, RECT& rect);

 // Вывести изображение карты в Image    
 // Выводится фрагмент карты, заданный параметром rect.
 // Заполняется палитра .
 // Изображение строится в текущем масштабе и составе объектов
 // Палитра Image только 256 цветов, размер точки 1 байт !
 // Если размеры заданного Image меньше размеров фрагмента -
 // изображение строится в пределах размеров Image.
 // lpImage - адрес первого байта области Image.
 // width и height - ширина и высота Image.
 // При ошибке в параметрах возвращает ноль

 int PaintToImage256(RGBQUAD * palette, char * lpImage,
                     long int width, long int height, RECT& rect);

 // Вывести изображение карты в метафайл

 int PaintToEmf(char* name, METAFILEBUILDPARM* parm);
 int PaintToEmfEx(char* name, METAFILEBUILDPARMEX* parm);
#endif   // WIN32API

 // Отобразить произвольный объект в пределах фрагмента
 // в условных знаках пользователя
 // image - описание вида объекта (см. MAPGDI.H),
 // data  - координаты объекта.
 // Координаты объекта заданы в соответствии с параметром place
 // С изображениями больше 32000х32000 работает только
 // под Windows NT (Windows 95 имеет 16-битовую графику)
 // При ошибке в параметрах возвращает ноль

  int _fastcall PaintUserObject(HDC hdc, RECT& rect,
                                PAINTPARM * image, PLACEDATA * data,
                                int place, TMap * map = 0);

 // Отобразить произвольный объект в пределах фрагмента
 // image - описание вида объекта (см. MAPGDI.H),
 // data  - координаты объекта.
 // offset - смещение координат объекта (в соответствии с place)
 // Координаты объекта заданы в соответствии с параметром place
 // Корректно работает с большими изображениями под Windows95 и NT,
 // При ошибке в параметрах возвращает ноль

  int PaintOffsetUserObject95(HDC hdc, RECT& rect,
                              PAINTPARM * image, PLACEDATA * data,
                              DOUBLEPOINT& offset,
                              int place, TMap * map = 0);

 // Отобразить произвольный объект в пределах фрагмента
 // image - описание вида объекта (см. MAPGDI.H),
 // data  - координаты объекта.
 // Координаты объекта заданы в соответствии с параметром place
 // Корректно работает с большими изображениями под Windows95 и NT,
 // При ошибке в параметрах возвращает ноль

  int _fastcall PaintUserObject95(HDC hdc, RECT& rect,
                                  PAINTPARM * image, PLACEDATA * data,
                                  int place, TMap * map = 0)
  {
    return PaintUserObject(hdc, rect, image, data, place, map, 0);
  }


  // Отобразить образец вида объекта по номеру записи
  // в классификаторе объектов
  //  text - текст всегда в кодировке WINDOWS
  // Используется в диалогах выбора вида объекта
  // При ошибке возвращает ноль

  int PaintExampleObject(HDC hdc, RECT& rect,
                         int incode, TMapRsc* rsc,
                         int visualtype = 0, char* text = 0);

  // Отобразить образец вида объекта по номеру записи
  // в классификаторе объектов и заданной метрике
  // При ошибке возвращает ноль
  int PaintExampleObject(HDC hdc, RECT& rect,
                         int incode, TMapRsc* rsc,
                         POLYDATAEX* data, int visualtype = 0);

  // Отобразить образец вида объекта по номеру функции
  //  text - текст всегда в кодировке WINDOWS, кроме функции IMG_TEXT
  //         (кодировка задана в параметрах структуры IMGTEXT)
  // Используется в диалогах выбора вида объекта
  // При ошибке возвращает ноль

  int PaintExampleObject(HDC hdc, RECT& rect,
                         int func, char* parm,
                         int colors, COLORREF* palette,
                         int visualtype = 0, char* text = 0,
                         int local = 0);

  // Отобразить образец вида объекта по заданной метрике
  // Используется в диалогах для отображения схем объектов
  // При ошибке возвращает ноль

  int PaintExampleObject(HDC hdc, RECT& rect,
                         int func, char* parm, POLYDATAEX* data,
                         int colors, COLORREF* palette,
                         int visualtype = 0);

  // Отобразить образец вида объекта по заданной метрике
  // в реальных цветах (с интенсивностью заливки - 100%)
  //  text - текст всегда в кодировке WINDOWS
  //         (если data != 0, то text игнорируется)
  // Используется в диалогах редактирования вида объекта
  // При ошибке возвращает ноль

  int PaintExampleObjectReal(HDC hdc, RECT& rect,
                             int func, char* parm, POLYDATAEX* data,
                             int colors, COLORREF* palette,
                             int visualtype = 0, char* text = 0);

  // Выделить на карте объекты, удовлетворяющие заданным условиям
  // select - условия отбора объектов,
  // color  - цвет, которым будут выделяться объекты на карте

  void PaintSelect95(HDC hdc, RECT& rect,
                     TMapSelect * select, COLORREF color);   

protected :

  // Отобразить произвольный объект в пределах фрагмента
  // image - описание вида объекта (см. MAPGDI.H),
  // data  - координаты объекта в области вывода !
  // Корректно работает с большими изображениями под Windows95 и NT,
  // При ошибке в параметрах возвращает ноль

  int _fastcall PaintUserObject95(HDC hdc, RECT& rect,
                                  PAINTPARM * image, POLYDATAEX * data, TMap * map)
  {
    return TMapPaint::PaintUserObject(hdc, rect, image, data, map);
  }

  //  Отобразить произвольный объект в пределах фрагмента
  //  image - описание вида объекта (см. MAPGDI.H),
  //  data  - координаты объекта.
  //  Координаты объекта заданы в соответствии с параметром place

  int _fastcall PaintUserObject(HDC hdc, RECT& rect,
                                PAINTPARM * image, PLACEDATA * data,
                                int place, TMap * map, POINT * offset);

  //  Отобразить произвольный объект в пределах фрагмента
  //  image - описание вида объекта (см. MAPGDI.H),
  //  data  - координаты объекта.
  //  Координаты объекта заданы в дискретах в листе

  int _fastcall PaintMapObject(HDC hdc, RECT& rect,
                               PAINTPARM * image, TObjectInfo * object, POINT * offset);


  /*********************************************************
  *                                                        *
  *      ФУНКЦИИ ОТОБРАЖЕНИЯ И ПЕЧАТИ ЭЛЕКТРОННОЙ КАРТЫ    *
  *   ЗАДАН ИДЕНТИФИКАТОР ОКНА, И ПОЗИЦИЯ ФРАГМЕНТА ВЫВОДА *
  *                ЭЛЕКТРОННОЙ КАРТЫ В ОКНЕ                *
  *                                                        *
  *********************************************************/

public :

 // Отобразить фрагмент карты в клиентной области окна
 // в текущих масштабе и составе объектов
 // hwnd  - идентификатор окна,
 // erase - признак стирания фона перед выводом,
 // (0 - фон не стирать, !=0 - очистить фрагмент цветом фона),
 // point - координаты верхнего левого угла окна на карте
 // в соответсвующей параметру place системе координат

  void View(HWND hwnd, int erase, DOUBLEPOINT * point,
            int place = MAP);

 // Выделить на карте объекты, удовлетворяющие заданным условиям
 // select - условия отбора объектов,
 // color  - цвет, которым будут выделяться объекты на карте
 // point - координаты верхнего левого угла окна на карте
 // в соответсвующей параметру place системе координат

  void ViewSelect(HWND hwnd, DOUBLEPOINT * point,
                             TMapSelect * select,
                             COLORREF color, int place = MAP);

 // Отобразить произвольный объект в пределах
 // клиентной области окна
 // Координаты объекта заданы в дискретах в листе
 // point - координаты верхнего левого угла окна на карте
 // в соответсвующей параметру place системе координат
 // При ошибке в параметрах возвращает ноль

  int ViewObject(HWND hwnd, DOUBLEPOINT * point,
                 TObjectInfo * object,
                 int place = MAP);

 // Отобразить произвольный объект в пределах
 // клиентной области окна
 // в условных знаках пользователя
 // image - описание вида объекта (см. MAPGDI.H),
 // Координаты объекта заданы в дискретах в листе
 // При ошибке в параметрах возвращает ноль

  int ViewMapObject(HWND hwnd,DOUBLEPOINT * point,
                    PAINTPARM * image,
                    TObjectInfo * info,
                    int place = MAP);

 // Отобразить произвольный объект в пределах
 // клиентной области окна
 // в условных знаках пользователя
 // image - описание вида объекта (см. MAPGDI.H),
 // offset - смещение координат объекта (в соответствии с place)
 // Координаты объекта заданы в дискретах в листе
 // При ошибке в параметрах возвращает ноль

  int ViewOffsetMapObject(HWND hwnd,DOUBLEPOINT * point,
                          PAINTPARM * image,
                          TObjectInfo * info, DOUBLEPOINT& offset,
                          int place = MAP);

  // Отобразить произвольный объект в пределах клиентной области окна
  // image - описание вида объекта (см. MAPGDI.H),
  // data  - координаты объекта.
  // offset - смещение координат объекта (в соответствии с place)
  // Координаты объекта заданы в соответствии с параметром place

  int ViewOffsetUserObject(HWND hwnd,DOUBLEPOINT * point,
                           PAINTPARM * image,
                           PLACEDATA * data,
                           DOUBLEPOINT& offset,int place = MAP,
                           TMap * map = 0);

 // Отобразить произвольный объект в пределах
 // клиентной области окна
 // image - описание вида объекта (см. MAPGDI.H),
 // data  - координаты объекта.
 // Координаты объекта заданы в соответствии с параметром place
 // При ошибке в параметрах возвращает ноль

  int ViewUserObject(HWND hwnd,
                     DOUBLEPOINT * point, PAINTPARM * image,
                     PLACEDATA * data, int place = MAP,TMap * map = 0);

  /*********************************************************
  *                                                        *
  *    ФУНКЦИИ УПРАВЛЕНИЯ ОТОБРАЖЕНИЕМ ЭЛЕКТРОННОЙ КАРТЫ   *
  *                                                        *
  *    ПРИ ИЗМЕНЕНИИ МАСШТАБА ОТОБРАЖЕНИЯ АВТОМАТИЧЕСКИ    *
  *       ИЗМЕНЯЮТСЯ ГАБАРИТЫ ИЗОБРАЖЕНИЯ В ПИКСЕЛАХ !     *
  *                                                        *
  *********************************************************/

public :

  // Изменить масштаб отображения относительно текущего
  //  Параметры:
  //          x, y - координаты предполагаемого "центра изображения"
  //                 (любой точки привязки) в окне в текущем масштабе
  //        change - коэффициент изменения текущего масштаба изображения
  //                 0 < change < 1 , для сжатия
  //                 1 < change < N , для увеличения
  //  Возвращает:   0 - масштаб не изменился,  1 - масштаб изменился
  //          x, y - координаты предполагаемого "центра изображения"
  //                 в окне относительно всей картинки
  //                 в новом масштабе отображения

  int ChangeViewScale(long int &x,long int &y,float change);


  // Запросить координаты района работ
  // в заданной системе координат (place)
  // dframe - адрес заполняемой структуры
  // При ошибке возвращает ноль

  int GetMapLimit(DFRAME * dframe, int place = MAP);


  // Установить масштаб отображения
  //  Параметры:
  //          x, y - координаты предполагаемого "центра изображения"
  //                 (любой точки привязки) в окне в текущем масштабе
  //         scale - реальный масштаб отображения, который желают получить
  //  Возвращает:   0 - масштаб не изменился,  1 - масштаб изменился
  //          x, y - координаты предполагаемого "центра изображения"
  //                 в окне относительно всей картинки
  //                 в новом масштабе отображения

  int SetViewScale(long int &x,long int &y,float scale);


  // Установить состав отображаемых объектов

  void SetViewSelect(TMapSelect * select);

  // Установить условия отображения объектов по имени листа
  // и номеру объекта в карте
  // listname - имя листа карты
  // key - номер объекта в карте (BaseKey)

  int SelectViewSample(char* listname, long int key);

  // Установить условия поиска/выделения объектов по имени листа
  // и номеру объекта в карте
  // listname - имя листа карты
  // key - номер объекта в карте (BaseKey)

  int SelectSeekSample(char* listname, long int key);

  // Установить список объектов для отбора
  // listname - имя листа карты
  // key - номер объекта в карте (BaseKey)

  int SetSample(TMapSelect* select, char* listname, long int key);

  // Установить список объектов для отбора
  // list - номер листа карты
  // key - номер объекта в карте (BaseKey)

  int SetSample(TMapSelect* select, long int list, long int key);

  // Установить список объектов для отбора
  // list - номер листа карты
  // number - порядковый номер объекта в листе

  int SetSampleByNumber(TMapSelect* select, long int list, long int number);

  // Очистить список объектов

  void ClearSample(TMapSelect* select);

  // Удалить объект из списка объектов для отбора
  // list - номер листа карты
  // number -  - порядковый номер объекта в листе

  int DeleteSampleByNumber(TMapSelect* select, long int list, long int number);


  /*********************************************************
  *                                                        *
  *        ФУНКЦИИ ПОИСКА ОБ'ЕКТОВ ЭЛЕКТРОННОЙ КАРТЫ       *
  *                                                        *
  *     ПОИСК МОЖЕТ ВЫПОЛНЯТЬСЯ В СИСТЕМАХ КООРДИНАТ :     *
  *       ИЗОБРАЖЕНИЯ (Picture)  - в пикселах,             *
  *       КАРТЫ,ИЛИ РАЙОНА (Map) - в дискретах,            *
  *       В ПРЯМОУГОЛЬНОЙ НА                               *
  *       МЕСТНОСТИ (Plane)      - в метрах,               *
  *       В ГЕОДЕЗИЧЕСКОЙ НА                               *
  *       МЕСТНОСТИ (Geo)        - в радианах.             *
  *                                                        *
  *********************************************************/

 // Флажки, определяющие порядок поиска объектов
 // Первый в цепочке,последний,следующий за найденым ранее,предыдущий

 enum SEEKTYPE { WO_FIRST = 0, WO_LAST = 2, WO_NEXT = 4, WO_BACK = 8};

 // ЗАПРОС ОБ'ЕКТА ПО ЗАДАННЫМ КООРДИНАТАМ В РАЙОНЕ
 // Поиск выполняется среди тех объектов,которые видны на экране !
 // info - указатель на существующий объект TObjectInfo,
 // в котором будет размещен результат поиска.
 // При поиске с флажками WO_NEXT,WO_BACK параметр info должен
 // указывать на результат предыдущего поиска.
 // frame - прямоугольная область поиска объекта в системе координат,
 // заданной переменной place
 // Если объект не найден - возвращает ноль,
 // иначе - возвращает значение info

 TObjectInfo * _fastcall WhatObject(TObjectInfo * info,DFRAME * frame,
                                    int flag = WO_FIRST);    // дискреты

 TObjectInfo * _fastcall WhatObject(TObjectInfo * info, DFRAME * frame,
                                    int flag, int place)
 { return WhatObjectFrame(info, frame, flag, place); }

 //  ЗАПРОС ОБ'ЕКТА ПО ЗАДАННЫМ КООРДИНАТАМ В РАЙОНЕ (ДИСКРЕТЫ).
 //  Если объект не найден - возвращает ноль.
 //  info - указатель на существующий объект TObjectInfo,
 //  в котором будет размещен результат поиска.
 //  При поиске с флажками WO_NEXT,WO_BACK параметр info должен
 //  указывать на результат предыдущего поиска.
 //  frame - прямоугольная область поиска объекта
 //  Если объект не найден - возвращает ноль,
 //  иначе - возвращает значение info

 TObjectInfo * _fastcall WhatObjectFrame(TObjectInfo * info,DFRAME * frame,
                                         int flag = WO_FIRST,
                                         int place = MAP,
                                         TMapSelect * select = 0);

 // Поиск объекта по имени листа (номенклатуре) и уникальному номеру
 // среди всех карт
 // info     - указатель на существующий объект TObjectInfo,
 // в котором будет размещен результат поиска.
 // listname - название (номенклатура) листа,
 // key      - идентификатор объекта в листе,
 // например: "SeekObject(...,KEY(256,12))",или "...KEY(16777228)".
 // Структура KEY - см. TObjectDesc (maphdr.h)
 // При ошибке возвращает ноль

 TObjectInfo * SeekObject(TObjectInfo * info,char * listname,KEY key);

 // Поиск объекта по уникальному номеру в заданном листе
 // info       - указатель на существующий объект TObjectInfo,
 // в котором будет размещен результат поиска.
 // listnumber - номер листа в районе
 // key        - идентификатор объекта в листе
 // nMap       - номер карты в списке (>0 - пользовательская)
 // При ошибке возвращает ноль

 TObjectInfo * SeekObject(TObjectInfo * info,int listnumber,
                          KEY key, int nMap = 0);

 // Поиск объекта по диапазону уникальных номеров в заданном листе
 //  info   - указатель на существующий объект TObjectInfo,
 //  select - границы диапазона номеров поиска и номер листа
 // Структура KEYSELECT - см. TMapSelect (mapselc.h)
 // При ошибке возвращает ноль

 TObjectInfo * SeekObject(TObjectInfo * info,KEYSELECT * select,
                          int flag = WO_FIRST, int nMap = 0);

 //  Поиск объектов по заданным условиям среди всех объектов
 //  info   - указатель на существующий объект TObjectInfo,
 //  select - условия поиска объекта
 //  nMap       - номер карты в списке (>0 - пользовательская),
 //  применяется с флажком WO_INMAP (например, WO_FIRST | WO_INMAP)
 //  Если объект не найден - возвращает ноль

 TObjectInfo * SeekObject(TObjectInfo * info,TMapSelect * select,
                          int flag, int nMap);

 TObjectInfo * SeekObject(TObjectInfo * info,TMapSelect * select,
                          int flag = WO_FIRST|WO_INMAP);

 //  Поиск объектов по заданным условиям среди отображаемых объектов
 //  (пересечение заданных условий с условиями отображения)
 //  info   - указатель на существующий объект TObjectInfo,
 //  select - условия поиска объекта
 //  Если объект не найден - возвращает ноль

 TObjectInfo * SeekViewObject(TObjectInfo * info,TMapSelect * select,
                              int flag = WO_FIRST, int nMap = 0);

 //  ПОИСК ОБ'ЕКТА, ИМЕЮЩЕГО С ДАННЫМ ОБ'ЕКТОМ СМЕЖНЫЙ УЧАСТОК .
 //  Поиск ведется в карте, где находится выбранный объект
 //  Если объект не найден - возвращает ноль.
 //  info   - указатель на существующий объект TObjectInfo,
 //  для которого надо найти смежные участки
 //  target - указатель на существующий объект TObjectInfo,
 //  в котором будет размещен результат поиска.
 //  При поиске с флажками WO_NEXT,WO_BACK параметр target должен
 //  указывать на результат предыдущего поиска.
 //  delta - допуск до объекта в метрах
 //  в структуре MAPADJACENTSECTION поле number для начального поиска
 //  должно быть равным 0.
 //  Если объект не найден - возвращает ноль,
 //  иначе - возвращает номер участка и заполненную структуру ADJACENTSECTION
 //  subject - 0 искать соседей только с внешним контуром  ( 1- с учетом подобъектов)

  int SeekAdjacentObject(TObjectInfo * info,
                        TObjectInfo * target,
                        MAPADJACENTSECTION * section,
                        TMapSelect * select,
                        double delta = 0.0,
                        int flag =  WO_FIRST | WO_INMAP,
                        int nMap = 0,
                        int subject = 0);

 // subject - номер подобъекта в info

 int SeekAdjacentObjectSubject(TObjectInfo * info,
                               TObjectInfo * target,
                               MAPADJACENTSECTION * section,
                               int * subject,
                               TMapSelect * select,
                               double delta = 0.0,
                               int flag =  WO_FIRST | WO_INMAP,
                               int nMap = 0);

 //  ПОИСК СОСЕДЕЙ, ИМЕЮЩИХ С ДАННЫМ ОБ'ЕКТОМ СМЕЖНЫЙ УЧАСТОК .
 //  Поиск ведется в карте, где находится выбранный объект
 //  Если соседи не найдены - возвращает ноль,
 //  иначе - количество соседей.
 //  info  - указатель на существующий объект TObjectInfo,
 //  для которого надо найти смежные участки
 //  MAPADJACENTLISTEX - память для соседей
 //  count - максимальное количество смежных участков
 //  delta - допуск до объекта в метрах
 //  point - интервалы с одинаковой первой и последней точкой
 //  0 - заносить в список, 1 - нет
 //  subject - 0 искать соседей только с внешним контуром  ( 1- с учетом подобъектов)

 int SeekAdjacentList(TObjectInfo * info,
                      MAPADJACENTLISTEX * list,
                      int count,
                      TMapSelect * select,
                      double delta = 0.0,
                      int point = 1, int nMap = 0,
                      int subject = 0);

 // массив под номера подобъектов для найденных интервалов в info

 int SeekAdjacentListSubject(TObjectInfo * info,
                             MAPADJACENTLISTEX * list,
                             int * subject,
                             int count,
                             TMapSelect * select,
                             double delta = 0.0,
                             int point = 1,
                             int nMap = 0);

 // Подсчитать сколько объектов удовлетворяет условиям
 // поиска на карте
 // Если select = 0,подсчитываются объекты по условиям поиска
 // всех карт (Map + Site)
 // При ошибке возвращает ноль

 int SeekSelectObjectCount(TMapSelect * select);

 // Подсчитать сколько объектов удовлетворяет условиям
 // отображения на карте
 // Если select = 0,подсчитываются объекты по условиям отображения
 // всех карт (Map + Site)
 // При ошибке возвращает ноль

 int ViewSelectObjectCount(TMapSelect * select);

 // Установить параметры поиска объектов по заданной области.
 // object   - объект-область поиска
 // distance - расстояние поиска в метрах
 // nmap     - номер карты для поиска; определяет границы поиска
 //            по картам.Если nmap = -1,устанавливается поиск по всем картам
 // Назначение флажков:
 // filter   - использовать/не использовать фильтр объектов (1/0)
 // inside   - пределы поиска по области: внутри/вне области(1/0)
 // visible  - учитывать/не учитывать видимость объектов на карте(1/0)
 // action   - предстоящая операция по области: выделение/поиск (1/0)

 int SetSeekArea(TObjectInfo* object, double distance,
                 int filter = 0, int inside = 1,
                 int visible = 0, int action = 0,
                 int nmap = -1);


  /*********************************************************
  *                                                        *
  * ФУНКЦИИ ОБОБЩЕННОГО ПОИСКА ОБ'ЕКТОВ ЭЛЕКТРОННОЙ КАРТЫ  *
  *                                                        *
  *********************************************************/

 // Запросить правило обобщенного поиска по картам
 // если number == -1, поиск будет выполняться по всем картам
 // (0 - карта местности, 1...n - пользовательские карты)
 // При ошибке возвращает число (-2)

 int GetTotalSeekMapRule();

 // Установить правило обобщенного поиска по картам
 // number - номер карты, по которой выполняется поиск,
 // если number == -1, поиск будет выполняться по всем картам
 // (0 - карта местности, 1...n - пользовательские карты)

 void SetTotalSeekMapRule(int number = -1);
 void SetTotalSeekMap(TMap * map  = 0);
 TMap * GetTotalSeekMap();

 // Установить правило обобщенного поиска для
 // отображаемых объектов карты
 // Если view == 0, поиск выполняется среди всех объектов
 // карты, иначе - среди отображаемых (SeekViewObject())

 void SetTotalSeekViewRule(int view = 0) { ViewSeekFlag = view; }
 int  GetTotalSeekViewRule() { return ViewSeekFlag; }

 // Запросить имеются ли на основной или пользовательской карте объекты,
 // удовлетворяющие заданным условиям поиска
 // hMap   - идентификатор открытой карты,
 // number - номер карты
 // (0 - карта местности, 1...n - пользовательские карты)
 // Если на карте есть подходящие объекты - возвращает ненулевое значение

 int IsTotalSeekMap(int number);

 // Запросить из контекстов правило поиска для
 // отображаемых объектов карты
 // (Условия поиска для отображаемых объектов задаются ранее
 // в контексте поиска каждой карты методами ТМарSelect)
 // Если возвращается 0, поиск установлен среди всех объектов
 // карты, 1 - среди отображаемых
 // При ошибке возвращает "-1"

 int  GetSelectedSeekViewRule();                     

 // Запросить из контекстов правило поиска  по картам
 //(Условия поиска по картам задаются ранее в контексте
 // поиска для каждой карты методами ТМарSelect)
 // Возвращает номер карты поиска,
 // если он == -1, установлен поиск по всем картам
 // (0 - карта местности, 1...n - пользовательские карты)
 // При ошибке возвращает "-2"

 int  GetSelectedSeekMapRule();                      

 // Выделить на карте объекты, удовлетворяющие условиям
 // обобщенного поиска
 // rect - координаты фрагмента карты (Draw) в изображении (Picture)
 // color  - цвет, которым будут выделяться объекты на карте
 // При ошибке возвращает ноль

 // Выделить на карте объекты, удовлетворяющие условиям
 // обобщенного поиска
 // rect - координаты фрагмента карты (Draw) в изображении (Picture)
 // color  - цвет, которым будут выделяться объекты на карте
 // При ошибке возвращает ноль

 int TotalPaintSelect95(HDC hDC, RECT& rect,
                        COLORREF color);

 // Подсчитать сколько объектов удовлетворяет условиям
 // обобщенного поиска
 // При ошибке возвращает ноль

 int TotalSeekObjectCount();

 // Обобщенный поиск объектов по заданным условиям
 // Условия обобщенного поиска вводятся заранее
 // (используются функции GetViewSelect(),GetSeekSelect())
 // info   - указатель на существующий объект TObjectInfo
 // При поиске с флажками WO_NEXT,WO_BACK параметр info должен
 // указывать на результат предыдущего поиска.
 // Если объект не найден - возвращает ноль

 TObjectInfo * TotalSeekObject(TObjectInfo * info,
                               int flag);

 // Установить признак выделения объектов по обобщенным
 // условиям поиска

 void SetTotalSelectFlag(int flag) {TotalSelectFlag = flag; }

 // Запросить признак выделения объектов по обобщенным
 // условиям поиска (если объекты не выделены - возвращает ноль)

 int GetTotalSelectFlag() { return TotalSelectFlag; }

  /*********************************************************
  *                                                        *
  *       ФУНКЦИИ ЗАПРОСА ИНФОРМАЦИИ О СЛОЯХ КАРТЫ         *
  *                                                        *
  *********************************************************/

public :

 // Запросить число слоев на карте
 // При ошибке возвращает ноль

  int GetLayerCount();

 // Запросить название слоя по его номеру
 // Номер первого слоя 0
 // При ошибке возвращает ноль

  const char * GetLayerName(int number);


  /*********************************************************
  *                                                        *
  *       ФУНКЦИИ ЗАПРОСА ИНФОРМАЦИИ О ЛИСТАХ КАРТЫ        *
  *                                                        *
  *********************************************************/

 // Определить собственный номер листа по заданным координатам
 // в районе в дискретах
 // Если лист не найден - возвращает ноль.
 // Если в одной точке несколько листов :
 // number - порядковый номер листа в перекрытии (начиная с 1).
 // Поиск всегда дает одинаковый порядок листов
 // При ошибке возвращает ноль

 int WhatListNumber(long int x,long int y, int number = 0);

 // Запросить имя листа по заданным координатам
 // в районе в дискретах
 // Если лист не найден - возвращает ноль

 const char * WhatListName(long x, long y, int number = 0);

 // Определить собственный номер листа по заданным координатам.
 // Система координат задана переменной place.
 // Если лист не найден - возвращает ноль.
 // Если в одной точке несколько листов :
 // number - порядковый номер листа в перекрытии (начиная с 1).
 // Поиск всегда дает одинаковый порядок листов
 // При ошибке возвращает ноль

 int WhatListNumber(double x,double y, int number = 0, int place = MAP);

 // Запросить имя листа по заданным координатам.
 // Система координат задана переменной place.
 // Если лист не найден - возвращает ноль

 const char * WhatListName(double x, double y, int number = 0, int place = MAP);

 // Запросить имя листа (ANSI) по его номеру
 // При ошибке возвращает ноль

 const char * WhatListName(int number)
   {
     return Map.GetListName(number);
   }

 // Запросить общее число листов в районе
 // При ошибке возвращает ноль

 int WhatListCount()
   {
     return Map.GetListCount();
   }

 // Определить какой по номеру карте принадлежит лист с именем listname
 // Возвращает номер карты или "-1" при ошибке

 int WhatListLayoutIs(char* listname);


  /*********************************************************
  *                                                        *
  *           ПРЕОБРАЗОВАНИЕ КООРДИНАТ ТОЧКИ               *
  *                                                        *
  *********************************************************/

 // Преобразование из дискретов на карте (районе работ)
 // в пикселы на изображении
 // Применение :
 // xpix = xdis; ypix = ydis;
 // MapToPicture(xpix,ypix);

  void MapToPicture(double &x, double &y);
  void MapToPicture(DOUBLEPOINT * map, POINT * picture);

 // Преобразование из дискретов на карте (районе работ)
 // в метры на местности

  void MapToPlane(double &x, double &y);

 // Преобразование из пикселов в изображении в координаты
 // карты (района работ) в дискретах

  void PictureToMap(long int &x, long int &y);
  void PictureToMap(double &x, double &y);

 // Преобразование из пикселов в изображении в координаты
 // на местности в метрах
 // Применение :
 // xmet = xdis; ymet = ydis;
 // PictureToPlane(xmet,ymet);

  void PictureToPlane(double &x, double &y);

 // Преобразование из метров на местности в дискреты
 // на карте (районе работ)

  void PlaneToMap(double &x, double &y);

 // Преобразование из метров на местности в пикселы на
 // изображении

  void PlaneToPicture(double &x, double &y);

  // Преобразование из метров на местности в пикселы на
  // изображении

  void PlaneToPicture(DOUBLEPOINT * plane, POINT * picture);

 // Преобразование из метров на местности в геодезические
 // координаты в радианах в соответствии с проекцией карты
 // (поддерживается не для всех карт !)
 // При ошибке возвращает ноль
 // Применение :
 // if (IsGeoSupported())      |  или :
 //   {                        |  if (IsGeoSupported())
 //     B = Xmet; L = Ymet;    |    {
 //     Plan2Geo(B,L);         |      Plan2Geo(B=Xmet,L=Ymet);
 //   }                        |    }

  int PlaneToGeo(double &Bx, double &Ly);

 // Преобразование из геодезических координат в радианах
 // в метры на местности в соответствии с проекцией карты
 // (поддерживается не для всех карт !)
 // При ошибке возвращает ноль

  int GeoToPlane(double &Bx, double &Ly);

  // Преобразование из геодезических координат в радианах
  // в точки устройства отображения в соответствии с проекцией карты
  // (поддерживается не для всех карт !)
  // При ошибке возвращает ноль

  int GeoToPicture(DOUBLEPOINT * geo, POINT * picture);

 // Преобразование из метров на местности (проекция карты)
 // в геодезические координаты в радианах (общеземной эллипсоид WGS84)
 // (поддерживается не для всех карт !)
 // При ошибке возвращает ноль
 // Применение :
 // if (IsGeoSupported())      |  или :
 //   {                        |  if (IsGeoSupported())
 //     B = Xmet; L = Ymet;    |    {
 //     PlaneToGeoWGS84(B,L);  |      PlaneToGeoWGS84(B=Xmet,L=Ymet);
 //   }                        |    }

 int PlaneToGeoWGS84(double &Bx, double &Ly);
 int PlaneToGeoWGS84(double &Bx, double &Ly, double &h);

 // Преобразование из метров на местности (проекция карты)
 // в геодезические координаты в радианах (эллипсоид Красовского)
 // (поддерживается не для всех карт !)
 // При ошибке возвращает ноль

 int PlaneToGeo42(double &Bx, double &Ly);
 int PlaneToGeo42(double &Bx, double &Ly, double &h);

 // Преобразование геодезических координат в радианах из системы 1942г
 // (эллипсоид Красовского) в геодезические координаты в радианах
 // (общеземной эллипсоид WGS84) (поддерживается не для всех карт !)
 // При ошибке возвращает ноль

 int Geo42ToGeoWGS84(double &Bx, double &Ly);
 int Geo42ToGeoWGS84(double &Bx, double &Ly, double &h);

 // Преобразование геодезических координат в радианах из системы WGS84
 // (общеземной эллипсоид WGS84) (поддерживается не для всех карт !)
 // в геодезические координаты в радианах системы 1942 г (эллипсоид Красовского)
 //  При ошибке возвращает ноль

 int GeoWGS84ToGeo42(double &Bx, double &Ly);
 int GeoWGS84ToGeo42(double &Bx, double &Ly, double &h);

 // Преобразование геодезических координат в радианах из системы ПЗ-90
 // (общеземной эллипсоид ПЗ-90) в геодезические координаты в радианах
 // системы 1942 г (эллипсоид Красовского) (поддерживается не для всех карт !)
 //  При ошибке возвращает ноль

 int GeoEP90ToGeo42(double &Bx, double &Ly);
 int GeoEP90ToGeo42(double &Bx, double &Ly, double &h);

 // Преобразование геодезических координат в радианах из системы 1942 г
 // (эллипсоид Красовского) в геодезические координаты в радианах 
 // системы ПЗ-90(общеземной эллипсоид ПЗ-90) (поддерживается не для всех карт !)
 //  При ошибке возвращает ноль

 int Geo42ToGeoEP90(double &Bx, double &Ly);
 int Geo42ToGeoEP90(double &Bx, double &Ly, double &h);

 // Преобразование геодезических координат в радианах из системы 1942 г
 // (эллипсоид Красовского) в прямоугольные в системе NAHRWAN в проекции UTM
 // (эллипсоид Кларка 1880г.) (поддерживается не для всех карт !)
 //  При ошибке возвращает ноль

 int Geo42ToPlaneUTM(double &Bx, double &Ly);
 int Geo42ToPlaneUTM(double &Bx, double &Ly, double &h);

 // Запрос - поддерживается ли пересчет к геодезическим
 // координатам из плоских прямоугольных и обратно
 // Если нет - возвращает ноль

  int IsGeoSupported() { return Map.IsGeo(); }

 // Преобразование набора точек из одной системы
 // координат в другую
 // src,tag - указатели на области размещения точек,
 // могут указывать на одну и ту же область памяти;
 // source,target - типы входной и выходной метрики (MAP,PLANE ...);
 // count - число преобразуемых точек.
 // Пересчет связанный с геодезическими координатами
 // будет выполняться только,если IsGeoSupported() != 0.

 void TransformPoints(DOUBLEPOINT * src,int source,
                      DOUBLEPOINT * tag,int target,
                      int count);


  /*********************************************************
  *                                                        *
  *     ФУНКЦИИ ТРЕХМЕРНОГО ОТОБРАЖЕНИЯ МАТРИЦЫ ВЫСОТ      *
  *                                                        *
  *********************************************************/

#ifndef HIDEMTR3D

  // Открыть сеанс трехмерной визуализации местности,
  // обеспеченной открытыми матрицами высот
  //   width  - ширина изображения,
  //   height - высота изображения.
  // Возвращает идентификатор открытого сеанса (TMtr3D*)
  // При ошибке возвращает ноль

  TMtr3D* OpenMtr3D(long int width, long int height);

  // Закрыть сеанс трехмерной визуализации местности

  void CloseMtr3D(TMtr3D* hMtr3D);

  // Отобразить фрагмент местности в трехмерном виде
  // parm - параметры отображения (см. MAPTYPE.H)

  void PaintMtr3D(TMtr3D* Mtr3D, HDC hDC, MTR3DVIEW* parm);

#endif  // !HIDEMTR3D

  /*********************************************************
  *                                                        *
  *      ФУНКЦИИ ЗАПРОСА ИМЕНИ INI-ФАЙЛА ДОКУМЕНТА         *
  *                                                        *
  *********************************************************/

public :

  // Записать новое имя INI-файла документа
  // При ошибке возвращает ноль

  char * SetMapIniName(const char * mapininame);

  // Запросить имя INI-файла документа
  // При ошибке возвращает ноль

  const char * GetMapIniName() { return MapIniName; }

  // ************************************************************
  //                                                            *
  //         СПЕЦИАЛЬНЫЕ ОПЕРАЦИИ                               *
  //                                                            *
  // ************************************************************

public :

 operator HMAP()
  {
    return (HMAP) this;
  }

 char MapDocName[MAX_PATH];   // Имя файла документа

 char MapIniName[MAX_PATH];   // Имя INI файла документа

 int  IsProjectActive;        // Признак открытия проекта
 char ProjectName[MAX_PATH];  // Имя файла проекта
};

//  Открыть доступ к карте
void _fastcall macInit(TMapAccess *mapacc);   

//  Закрыть вcе данные
void _fastcall macFree(TMapAccess *mapacc);

//  Открыть растровые данные
int _fastcall macOpenRst(TMapAccess *mapacc, 
                         const char * name, int mode);

//  Закрыть растровые данные
void _fastcall macCloseRst(TMapAccess *mapacc, int number);

//  Открыть матричные данные
int _fastcall macOpenMtr(TMapAccess *mapacc,
                         const char * mtrname, int mode);

//  Закрыть матричные данные
void _fastcall macCloseMtr(TMapAccess *mapacc, int number);

//  Открыть векторные данные
int _fastcall macOpenMap(TMapAccess *mapacc,
                         const char * mapname,int mode);

//  Открыть карту обстановки
int _fastcall macOpenSit(TMapAccess *mapacc,
                         const char * name, int mode);

//  Закрыть векторные данные
void _fastcall macCloseMap(TMapAccess *mapacc);

//  Закрыть карту обстановки
void _fastcall macCloseSit(TMapAccess *mapacc, int number);

// Закрыть все данные электронной карты
void _fastcall macCloseData(TMapAccess *mapacc);

// Открыть данные с автоматическим определением их типа    
// При ошибке возвращает ноль
int _fastcall macOpenData(TMapAccess *mapacc,
                          const char * name, int mode);


// Выполнить согласование данных электронной карты
// Если состояние данных изменилось - возвращает 1,
// иначе 0
int _fastcall macAdjustData(TMapAccess *mapacc);

  /*********************************************************
  *                                                        *
  *          ФУНКЦИИ ОТОБРАЖЕНИЯ ЭЛЕКТРОННОЙ КАРТЫ         *
  *           ПАРАМЕТРЫ КОНТЕКСТА ПОДГОТОВЛЕНЫ (HDC)       *
  *                                                        *
  *********************************************************/

// Отобразить образец вида объекта по номеру записи
// в классификаторе объектов
//  text - текст всегда в кодировке WINDOWS
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByIncode(TMapAccess* mac, HDC hdc, RECT* rect,
                                            int incode, TMapRsc* rsc,
                                            int visualtype, char* text);

// Отобразить образец вида объекта по номеру записи
// в классификаторе объектов и заданной метрике
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByIncodeData(TMapAccess* mac, HDC hdc, RECT* rect,
                                                int incode, TMapRsc* rsc,
                                                POLYDATAEX* data, int visualtype);

// Отобразить образец вида объекта по номеру функции
//  text - текст всегда в кодировке WINDOWS, кроме функции IMG_TEXT
//         (кодировка задана в параметрах структуры IMGTEXT)
//  factor - коэффициент увеличения образца
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByFunc(TMapAccess* mac, HDC hdc, RECT* rect,
                                          int func, char* parm,
                                          int colors, COLORREF* palette,
                                          int visualtype, char* text,
                                          int local, float factor);

// Отобразить образец вида объекта по заданной метрике
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByFuncData(TMapAccess* mac, HDC hdc, RECT* rect,
                                              int func, char* parm, POLYDATAEX* data,
                                              int colors, COLORREF* palette,
                                              int visualtype);

#ifdef LINUXAPI
// Отобразить образец вида объекта по заданной метрике                  
// в Dib, вид экранный
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByFuncDataToDib(TMapAccess* mac, RECT* rect,
                                              int func, char* parm, POLYDATAEX* data,
                                              int colors, COLORREF* palette);


// Отобразить образец вида объекта по номеру функции и параметрам     //  
// в Dib, вид экранный
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectByFuncToDib(TMapAccess* mac, RECT* rect,
                                              int func, char* parm, int colors, COLORREF* palette,
                                               char* text,int local, float factor);   
#endif
// Отобразить образец вида объекта по заданной метрике
// в реальных цветах (с интенсивностью заливки - 100%)
//  text - текст всегда в кодировке WINDOWS
//         (если data != 0, то text игнорируется)
// При ошибке возвращает ноль
int _fastcall macPaintExampleObjectRealByFuncData(TMapAccess* mac, HDC hdc, RECT* rect,
                                                  int func, char* parm, POLYDATAEX* data,
                                                  int colors, COLORREF* palette,
                                                  int visualtype, char* text);

  /*********************************************************
  *                                                        *
  *           ПРЕОБРАЗОВАНИЕ КООРДИНАТ ТОЧКИ               *
  *                                                        *
  *********************************************************/

// Преобразование из пикселов в изображении в координаты
// карты (района работ) в дискретах
void _fastcall macPictureToMap(TMapAccess * mapacc, double * x,
                                                    double * y);

// Преобразование из дискретов на карте (районе работ)
// в пикселы на изображении
void _fastcall macMapToPicture(TMapAccess * mapacc, double * x,
                                                    double * y);

// Преобразование из дискретов на карте (районе работ)
// в пикселы на изображении
void _fastcall macMapToPictureDraw(TMapAccess * mapacc, DOUBLEPOINT * map,
                                   POINT * picture);

// Преобразование из дискретов на карте (районе работ)
// в метры на местности
void _fastcall macMapToPlane(TMapAccess * mapacc, double * x, double * y);

// Преобразование из метров на местности в дискреты
// на карте (районе работ)
void _fastcall macPlaneToMap(TMapAccess * mapacc, double * x, double * y);

// Преобразование из метров на местности в геодезические
// координаты в радианах в соответствии с проекцией карты
int _fastcall macPlaneToGeo(TMapAccess * mapacc, double * Bx, double * Ly);

// Преобразование из геодезических координат в радианах
// в метры на местности в соответствии с проекцией карты
int _fastcall macGeoToPlane(TMapAccess * mapacc, double * Bx, double * Ly);

//  Преобразование из пикселов в изображении в координаты
//  на местности в метрах
void _fastcall macPictureToPlane(TMapAccess * mapacc, double * x, double * y);

// Преобразование из метров на местности в пикселы на
// изображении
void _fastcall macPlaneToPicture(TMapAccess * mapacc, double * x, double * y);

// Преобразование из метров на местности в пикселы на
// изображении
void _fastcall macPlaneToPictureDraw(TMapAccess * mapacc, DOUBLEPOINT * plane,
                                     POINT * picture);

// Преобразование из геодезических координат в радианах
// в точки устройства отображения в соответствии с проекцией карты
int _fastcall macGeoToPicture(TMapAccess * mapacc,
                              DOUBLEPOINT * geo, POINT * picture);

// Преобразование набора точек из одной системы
// координат в другую
void _fastcall macTransformPoints(TMapAccess * mapacc,
                                  DOUBLEPOINT * src,int source,
                                  DOUBLEPOINT * tag,int target,
                                  int count);

// Преобразование геодезических координат в радианах из системы WGS84
// (общеземной эллипсоид WGS84) в геодезические координаты в радианах
// системы 1942 г (эллипсоид Красовского) (поддерживается не для всех карт !)
int _fastcall macGeoWGS84ToGeo42(double * Bx, double * Ly, double * H);

  /*********************************************************
  *                                                        *
  *        ФУНКЦИИ ПОИСКА ОБ'ЕКТОВ ЭЛЕКТРОННОЙ КАРТЫ       *
  *                                                        *
  *     ПОИСК МОЖЕТ ВЫПОЛНЯТЬСЯ В СИСТЕМАХ КООРДИНАТ :     *
  *       ИЗОБРАЖЕНИЯ (Picture)  - в пикселах,             *
  *       КАРТЫ,ИЛИ РАЙОНА (Map) - в дискретах,            *
  *       В ПРЯМОУГОЛЬНОЙ НА                               *
  *       МЕСТНОСТИ (Plane)      - в метрах,               *
  *       В ГЕОДЕЗИЧЕСКОЙ НА                               *
  *       МЕСТНОСТИ (Geo)        - в радианах.             *
  *                                                        *
  *********************************************************/

//  Установить состав отображаемых объектов
void _fastcall macSetViewSelect(TMapAccess* mapacc, TMapSelect * select);

// Установить условия отображения объектов по имени листа
// и номеру объекта в карте
// listname - имя листа карты
// key - номер объекта в карте (BaseKey)
int _fastcall macSelectViewSample(TMapAccess* mapacc,
                                  char* listname, long int key);

// Установить условия поиска/выделения объектов по имени листа
// и номеру объекта в карте
// listname - имя листа карты
// key - номер объекта в карте (BaseKey)
int _fastcall macSelectSeekSample(TMapAccess* mapacc,
                                  char* listname, long int key);

// Установить список объектов для отбора
// listname - имя листа карты
// key - собственный номер объекта в карте (BaseKey)
int _fastcall macSetSampleByKeyListName(TMapAccess* mapacc,
                           TMapSelect* select, char* listname, long key);

// Установить список объектов для отбора
// list - номер листа
// key - собственный номер объекта в карте (BaseKey)
int _fastcall macSetSampleByKeyListNumber(TMapAccess* mapacc,
                          TMapSelect* select, long int list, long int key);

// Установить список объектов для отбора
// list - номер листа
// number - порядковый номер объекта в листе
int _fastcall macSetSampleByNumber(TMapAccess* mapacc, TMapSelect* select,
                                   long int list, long int number);

// Очистить список объектов
void _fastcall macClearSample(TMapAccess* mapacc, TMapSelect* select);

// Удалить объект из списка объектов для отбора
// list - номер листа карты
// number - порядковый номер объекта в листе
int _fastcall macDeleteSampleByNumber(TMapAccess* mapacc,
                       TMapSelect* select, long int list, long int number);

// Установить параметры поиска объектов по заданной области.
// object   - объект-область поиска
// distance - расстояние поиска в метрах
 // nmap    - номер карты для поиска; определяет границы поиска
 //           по картам.Если nmap = -1, устанавливается поиск по всем картам
// флажки:
// filter   - использовать/не использовать фильтр объектов (1/0)
// inside   - границы поиска объектов по области :
//            1 - внутри области, 2 - целиком внутри области,
//            0 - по расстоянию.
// visible  - учитывать/не учитывать видимость объектов на карте(1/0)
// action   - предстоящая операция по области: выделение/поиск (1/0)
// При ошибке возвращает ноль
int _fastcall macSetSeekArea(TMapAccess* mapacc,
                             TObjectInfo* object, double distance,
                             int filter, int inside, int visible,
                             int action, int nmap);

// Зафиксировать в контексте поиска количественный состав карты
// При ошибке возвращает ноль
// (Используется при редактировании карты для исключения из поиска вновь
// созданных объектов)                                      

long int _fastcall macFreezeMapContents(TMapAccess* mapacc);

// Сбросить в контексте поиска данные о количественном составе карты
// При ошибке возвращает ноль                               

long int _fastcall macDefreezeMapContents(TMapAccess* mapacc);


  /*********************************************************
  *                                                        *
  * ФУНКЦИИ ОБОБЩЕННОГО ПОИСКА ОБ'ЕКТОВ ЭЛЕКТРОННОЙ КАРТЫ  *
  *                    
  *********************************************************/

//  Установить правило обобщенного поиска по картам
//  number - номер карты, по которой выполняется поиск,
//  если number == -1, поиск будет выполняться по всем картам
//  (0 - карта местности, 1...n - пользовательские карты)
void _fastcall macSetTotalSeekMapRule(TMapAccess* mapacc, int number);

int _fastcall macGetTotalSeekMapRule(TMapAccess* mapacc);

void _fastcall macSetTotalSeekMap(TMapAccess* mapacc, TMap * map);

TMap * _fastcall macGetTotalSeekMap(TMapAccess* mapacc);

// Запросить из контекста правило поиска для
// отображаемых объектов карты
// (Условия поиска для отображаемых объектов задаются ранее
// в контексте поиска каждой карты методами ТМарSelect)
// Если возвращается 0, поиск установлен среди всех объектов
// карты, 1 - среди отображаемых
// При ошибке возвращает "-1"
int _fastcall macGetSelectedSeekViewRule(TMapAccess* mapacc);

// Запросить из контекстов правило поиска  по картам
//(Условия поиска по картам задаются ранее в контексте
// поиска для каждой карты методами ТМарSelect)
// Возвращает номер карты поиска,
// если он == -1, установлен поиск по всем картам
// (0 - карта местности, 1...n - пользовательские карты)
int _fastcall macGetSelectedSeekMapRule(TMapAccess* mapacc);

// Определить общие габариты объектов, соответствующие заданным
// условиям
// Габариты рассчитываются в метрах
// При ошибке возвращает ноль
int _fastcall macGetTotalSeekBorder(TMapAccess* mapacc,
                                    DFRAME * border);

// Подсчитать сколько объектов удовлетворяет условиям
// обобщенного поиска
// При ошибке возвращает ноль
int _fastcall macTotalSeekObjectCount(TMapAccess* mapacc);

// Обобщенный поиск объектов по заданным условиям
// Условия обобщенного поиска вводятся заранее
// (используются функции GetViewSelect(),GetSeekSelect())
// info   - указатель на существующий объект TObjectInfo
// При поиске с флажками WO_NEXT,WO_BACK параметр info должен
// указывать на результат предыдущего поиска.
// Если объект не найден - возвращает ноль
TObjectInfo * _fastcall macTotalSeekObject(TMapAccess* mapacc,
                                           TObjectInfo * info, int flag);

// Выделить на карте объекты, удовлетворяющие условиям
// обобщенного поиска
// rect - координаты фрагмента карты (Draw) в изображении (Picture)
// color  - цвет, которым будут выделяться объекты на карте
// При ошибке возвращает ноль
int _fastcall macTotalPaintSelect95(TMapAccess* mapacc, HDC hDC,
                                    RECT * rect, COLORREF color);

// Поиск объекта по уникальному номеру в заданном листе
// При ошибке возвращает ноль
int _fastcall macSeekObjectInList(TMapAccess* mapacc,
                                  TObjectInfo * info, int list,
                                  int key, int nMap);

// Поиск объекта по диапазону уникальных номеров в заданном листе
// При ошибке возвращает ноль
TObjectInfo * _fastcall macSeekObjectByKey(TMapAccess* mapacc,
                               TObjectInfo * info,KEYSELECT * select,
                               int flag, int nMap);

// Поиск объектов по заданным условиям среди всех объектов
// Если объект не найден - возвращает ноль
TObjectInfo * _fastcall macSeekObject(TMapAccess* mapacc,
                           TObjectInfo * info,TMapSelect * select,
                           int flag);
TObjectInfo * _fastcall macSeekObjectInMap(TMapAccess* mapacc,
                               TObjectInfo * info, TMapSelect * select,
                               int flag, int nMap);

// Поиск объектов по заданным условиям среди отображаемых объектов
// (пересечение заданных условий с условиями из переменной "Select")
// Если объект не найден - возвращает ноль
TObjectInfo * _fastcall macSeekViewObject(TMapAccess* mapacc,
                                   TObjectInfo * info, TMapSelect * select,
                                   int flag, int nMap);

// Поиск объекта по названию листа (номенклатуре) и уникальному номеру
// среди всех карт
// info     - указатель на существующий объект TObjectInfo,
// listname - название (номенклатура) листа
// в котором будет размещен результат поиска.
// При ошибке возвращает ноль
int _fastcall macSeekObjectByListName(TMapAccess* mapacc,
                                      TObjectInfo* info, char* listname, int key);

//  ПОИСК ОБ'ЕКТА, ИМЕЮЩЕГО С ДАННЫМ ОБ'ЕКТОМ СМЕЖНЫЙ УЧАСТОК .
//  Поиск ведется в карте, где находится выбранный объект
//  Если объект не найден - возвращает ноль.
//  info   - указатель на существующий объект TObjectInfo,
//  для которого надо найти смежные участки
//  target - указатель на существующий объект TObjectInfo,
//  в котором будет размещен результат поиска.
//  При поиске с флажками WO_NEXT,WO_BACK параметр target должен
//  указывать на результат предыдущего поиска.
//  delta - допуск до объекта в метрах
//  в структуре MAPADJACENTSECTION поле number для первого поиска
//  должно быть равным 0.
//  Если объект не найден - возвращает ноль,
//  иначе - возвращает номер участка и заполненную структуру MAPADJACENTSECTION
//  subject  1 - искать с учетом подобъектов (0 - только с внешним контуром)
int _fastcall macSeekAdjacentObject(TMapAccess *mapacc,
                                    TObjectInfo *info,
                                    TObjectInfo *target,
                                    MAPADJACENTSECTION *section,
                                    TMapSelect *select,
                                    double delta,
                                    int flag,
                                    int nMap,
                                    int subject);

int _fastcall macSeekAdjacentObjectSubject(TMapAccess *mapacc,
                                           TObjectInfo *info,
                                           TObjectInfo *target,
                                           MAPADJACENTSECTION *section,
                                           int *subject,
                                           TMapSelect *select,
                                           double delta,
                                           int flag,
                                           int nMap);

//  ПОИСК СОСЕДЕЙ, ИМЕЮЩИХ С ДАННЫМ ОБ ЕКТОМ СМЕЖНЫЙ УЧАСТОК .
//  Поиск ведется в карте, где находится выбранный объект
//  Если соседи не найдены - возвращает ноль.
//  иначе - количество соседей.
//  info   - указатель на существующий объект TObjectInfo,
//  для которого надо найти смежные участки
//  MAPADJACENTLISTEX - память для соседей
//  count - максимальное количество смежных участков
//  delta - допуск до объекта в метрах
//  point - интервалы с одинаковой первой и последней точкой
//  0 - заносить в список, 1 - нет
//  subject  1 - искать с учетом подобъектов (0 - только с внешним контуром)
int _fastcall macSeekAdjacentList(TMapAccess *mapacc,
                                  TObjectInfo *info,
                                  MAPADJACENTLISTEX *list,
                                  int count,
                                  TMapSelect *select,
                                  double delta,
                                  int point,
                                  int nMap,
                                  int subject);

int _fastcall macSeekAdjacentListSubject(TMapAccess *mapacc,
                                         TObjectInfo *info,
                                         MAPADJACENTLISTEX *list,
                                         int *subject,
                                         int count,
                                         TMapSelect *select,
                                         double delta,
                                         int point,
                                         int nMap);

// Определить какой по номеру карте принадлежит лист с именем listname
// Возвращает номер карты или "-1" при ошибке
int _fastcall macWhatListLayoutIs(TMapAccess* mac, char* listname);

//  Определить собственный номер листа по заданным координатам
//  (метры), если лист не найден - возвращает ноль;
//  если в одной точке несколько листов :
//  number - порядковый номер листа в перекрытии (начиная с 1),
//  поиск всегда дает одинаковый порядок листов
int _fastcall macWhatListNumber(TMapAccess* mac,
                                double * x, double * y, int number);

//  Определить собственный номер листа по заданным координатам
//  если лист не найден - возвращает ноль;
//  если в одной точке несколько листов :
//  number - порядковый номер листа в перекрытии (начиная с 1),
//  поиск всегда дает одинаковый порядок листов
//  При ошибке возвращает ноль
int _fastcall macWhatListNumberByXY(TMapAccess* mac,
                                    double * x,double * y,
                                    int number,int place);

// Запросить имя листа (ANSI) по его номеру
// При ошибке возвращает ноль
const char * _fastcall macWhatListNameByNumber(TMapAccess* mac,int number);

//  Запросить имя листа по заданным координатам
//  если лист не найден - возвращает ноль
const char * _fastcall macWhatListName(TMapAccess* mac,
                                       double * x,double * y,int number,int place);

// Запросить имя листа по заданным координатам в дискретах
// При ошибке возвращает ноль
const char * _fastcall macWhatListNameByDis(TMapAccess* mac, long x, long y, int number);

// Подсчитать сколько объектов удовлетворяет условиям
// отображения на карте
// Если select = 0,подсчитываются объекты по условиям отображения
// всех карт (Map + Site)
// При ошибке возвращает ноль
int _fastcall macViewSelectObjectCount(TMapAccess* mac, TMapSelect * select);

// Подсчитать сколько объектов удовлетворяет условиям
// поиска на карте
// Если select = 0,подсчитываются объекты по условиям поиска
// всех карт (Map + Site)
// При ошибке возвращает ноль
int _fastcall macSeekSelectObjectCount(TMapAccess* mac, TMapSelect * select);


#ifndef HIDEMTQ          

// ===========================================================
//           МАТРИЦЫ КАЧЕСТВ    
// ===========================================================

// Открыть матрицу качеств
int _fastcall macOpenMtq(TMapAccess *mapacc,
                         const char * mtrname,int mode);

//  Закрыть матрицу качеств
void _fastcall macCloseMtq(TMapAccess *mapacc, int number);

#endif


#endif  // MAPACCES_H

